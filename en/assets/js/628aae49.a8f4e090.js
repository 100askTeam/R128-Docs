"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4779],{432:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>i,contentTitle:()=>a,default:()=>f,frontMatter:()=>c,metadata:()=>_,toc:()=>x});var s=e(5893),t=e(1151);const c={},a="Smart Card",_={id:"developer-guide/part2/chapter23",title:"Smart Card",description:"\u6a21\u5757\u4ecb\u7ecd",source:"@site/docs/developer-guide/part2/chapter23.md",sourceDirName:"developer-guide/part2",slug:"/developer-guide/part2/chapter23",permalink:"/en/developer-guide/part2/chapter23",draft:!1,unlisted:!1,editUrl:"https://github.com/100askTeam/R128-Docs/tree/main/docs/developer-guide/part2/chapter23.md",tags:[],version:"current",frontMatter:{},sidebar:"classpartoneSidebar",previous:{title:"SID",permalink:"/en/developer-guide/part2/chapter22"},next:{title:"USB",permalink:"/en/developer-guide/part2/chapter24"}},i={},x=[{value:"\u6a21\u5757\u4ecb\u7ecd",id:"\u6a21\u5757\u4ecb\u7ecd",level:2},{value:"\u6a21\u5757\u914d\u7f6e",id:"\u6a21\u5757\u914d\u7f6e",level:2},{value:"\u6e90\u7801\u7ed3\u6784",id:"\u6e90\u7801\u7ed3\u6784",level:2},{value:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",level:2},{value:"SCR \u547d\u4ee4\u679a\u4e3e",id:"scr-\u547d\u4ee4\u679a\u4e3e",level:3},{value:"SCR ATA \u6570\u636e\u7ed3\u6784\u4f53",id:"scr-ata-\u6570\u636e\u7ed3\u6784\u4f53",level:3},{value:"SMARTCARD \u521d\u59cb\u5316\u63a5\u53e3",id:"smartcard-\u521d\u59cb\u5316\u63a5\u53e3",level:3},{value:"SMARTCARD \u6d4b\u8bd5\u63a5\u53e3",id:"smartcard-\u6d4b\u8bd5\u63a5\u53e3",level:3}];function p(n){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"smart-card",children:"Smart Card"}),"\n",(0,s.jsx)(r.h2,{id:"\u6a21\u5757\u4ecb\u7ecd",children:"\u6a21\u5757\u4ecb\u7ecd"}),"\n",(0,s.jsx)(r.p,{children:"\u667a\u80fd\u5361\u8bfb\u53d6\u5668\uff08SCR\uff09\u662f\u4e00\u79cd\u901a\u4fe1\u63a7\u5236\u5668\uff0c\u53ef\u5728\u7cfb\u7edf\u548c\u667a\u80fd\u5361\u4e4b\u95f4\u4f20\u8f93\u6570\u636e\u3002\u63a7\u5236\u5668\u53ef\u4ee5\u6267\u884c\u5b8c\u6574\u7684\u667a\u80fd\u5361\u4f1a\u8bdd\uff0c\u5305\u62ec\u505c\u7528\u5361\u6fc0\u6d3b\u5361\uff0c\u51b7/\u70ed\u91cd\u7f6e\uff0c\u91cd\u7f6e\u5e94\u7b54\uff08ATR\uff09\u54cd\u5e94\u63a5\u6536\uff0c\u6570\u636e\u4f20\u8f93\u7b49\u3002"}),"\n",(0,s.jsx)(r.h2,{id:"\u6a21\u5757\u914d\u7f6e",children:"\u6a21\u5757\u914d\u7f6e"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"Kernel Setup ---\x3e\n    Drivers Setup ---\x3e\n        SoC HAL Drivers ---\x3e\n            smartcard devices ---\x3e\n                [*] enable smartcard driver\n"})}),"\n",(0,s.jsx)(r.h2,{id:"\u6e90\u7801\u7ed3\u6784",children:"\u6e90\u7801\u7ed3\u6784"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:"rtos-hal/\n|--hal/source/smartcard/scr_hal.c // hal\u5c42\u63a5\u53e3\u4ee3\u7801\n"})}),"\n",(0,s.jsx)(r.h2,{id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",children:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e"}),"\n",(0,s.jsx)(r.p,{children:"\u5934\u6587\u4ef6"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:"#include <sunxi_hal_scr.h>\n"})}),"\n",(0,s.jsx)(r.h3,{id:"scr-\u547d\u4ee4\u679a\u4e3e",children:"SCR \u547d\u4ee4\u679a\u4e3e"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:"enum scr_cmd {\n    SCR_IOCGSTATUS = 0,\n    SCR_IOCRESET,\n    SCR_IOCGATR,\n    SCR_IOCGPARA,\n    SCR_IOCSPARA,\n    SCR_IOCGATRPARA,\n    SCR_IOCGPPSPARA,\n    SCR_IOCWRDATA,\n};\n"})}),"\n",(0,s.jsx)(r.h3,{id:"scr-ata-\u6570\u636e\u7ed3\u6784\u4f53",children:"SCR ATA \u6570\u636e\u7ed3\u6784\u4f53"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:"struct scr_atr {\n    unsigned char atr_len;\n    unsigned char atr_data[MAX_ATR_LEN];\n};\n"})}),"\n",(0,s.jsx)(r.h3,{id:"smartcard-\u521d\u59cb\u5316\u63a5\u53e3",children:"SMARTCARD \u521d\u59cb\u5316\u63a5\u53e3"}),"\n",(0,s.jsx)(r.p,{children:"SMARTCARD \u6a21\u5757\u521d\u59cb\u5316\uff0c\u4e3b\u8981\u521d\u59cb\u5316\u91c7\u6837\u7387\u3001\u901a\u9053\u9009\u62e9\u53ca\u6ce8\u518c\u4e2d\u65ad\u7b49"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:"hal_scr_status_t hal_scr_init(void);\n"})}),"\n",(0,s.jsx)(r.p,{children:"\u53c2\u6570\uff1a"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"\u65e0"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"\u8fd4\u56de\u503c"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"0\uff1a\u6210\u529f"}),"\n",(0,s.jsx)(r.li,{children:"\u8d1f\u6570\uff1a\u5931\u8d25"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"smartcard-\u6d4b\u8bd5\u63a5\u53e3",children:"SMARTCARD \u6d4b\u8bd5\u63a5\u53e3"}),"\n",(0,s.jsx)(r.p,{children:"SMARTCARD \u6a21\u5757\u529f\u80fd\u6d4b\u8bd5"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:"hal_scr_test(enum scr_cmd cmd, void *arg)\n"})}),"\n",(0,s.jsx)(r.p,{children:"\u53c2\u6570\uff1a"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"cmd\uff1a\u547d\u4ee4"}),"\n",(0,s.jsx)(r.li,{children:"arg\uff1a\u53c2\u6570"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"\u8fd4\u56de\u503c"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"0\uff1a\u6210\u529f"}),"\n",(0,s.jsx)(r.li,{children:"\u8d1f\u6570\uff1a\u5931\u8d25"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <interrupt.h>\n#include <irqs.h>\n#include <string.h>\n#include <console.h>\n#include <param.h>\n#include <hal_osal.h>\n#include <hal_timer.h>\n#include <hal_atomic.h>\n#include "hal_clk.h"\n#include <hal_gpio.h>\n#include <hal_reset.h>\n\n#include <sunxi_hal_scr.h>\n\n#include "scr_test.h"\n\n#define SCR_TEST_INFO  printf\n#define SCR_TEST_DBG   printf\n#define get_wvalue  readl\n#define APB2CLK 24000000\n\nconst unsigned int SCR_REG_DEFAULT[] = {12             //reg Count\n                               ,0x00000000 ,0x000 ,0x01ff0f07   //reg 0: (default, addr, mask)\n                               ,0x00000000 ,0x004 ,0x00ff1e1f\n                               ,0x00000000 ,0x008 ,0x00ff1e1f\n                               ,0x00000101 ,0x00c ,0x00000707\n                               ,0x00000000 ,0x010 ,0x1f1f1f1f //0x1f001f1f //\n                               ,0x00000000 ,0x014 ,0x000000ff\n                               ,0x00000000 ,0x018 ,0xffffffff\n                               ,0x00000000 ,0x01c ,0x00ffffff\n                               ,0x00000000 ,0x020 ,0xffff00ff\n                               ,0x00000000 ,0x030 ,0x000000ff\n                               ,0x00000000 ,0x03c ,0xffffffff\n                               ,0x000003ff ,0x040 ,0xffffffff\n                               };\n\nconst unsigned int SCR_REG_RW[]    =   {12               //reg Count\n                               ,0x01  //Byte|Hword|Word\n                               ,0x00000000 ,0x000 ,0x01ff0007   //reg 0: (default, addr, mask)\n                               ,0x00000000 ,0x004 ,0x00ff1e1f\n                               ,0x00000000 ,0x008 ,0x00000000\n                               ,0x00000101 ,0x00c ,0x00000000\n                               ,0x00000000 ,0x010 ,0x1f1f0000 //0x1f000000 //\n                               ,0x00000000 ,0x014 ,0x000000ff\n                               ,0x00000000 ,0x018 ,0xffffffff\n                               ,0x00000000 ,0x01c ,0x00ffffff\n                               ,0x00000000 ,0x020 ,0xffff00ff\n                               ,0x00000000 ,0x030 ,0x000000fd\n                               ,0x00000000 ,0x03c ,0x00000000\n                               ,0x000003ff ,0x040 ,0xffffffff\n                               };\n\nuint8_t ic_card_atr[SMART_CARD_NUM][30] = {\n    { 7, 0x3b, 0x93, 0x11, 0x00, 0x00, 0x40, 0x41 }, //\u83b1\u897f\u6709\u7ebf\n    { 18, 0x3b, 0x7d, 0x94, 0x00, 0x00, 0x57, 0x44, 0x53, 0x67, 0x96, 0x86,\n        0x93, 0x03, 0x9d, 0xf7, 0x10, 0x00, 0x9d }, //\u795e\u5dde\u5927\u4f17\u53611\n    { 15, 0x3b, 0xb9, 0x94, 0x00, 0x40, 0x14, 0x47, 0x47, 0x33, 0x53, 0x30,\n        0x35, 0x41, 0x53, 0x30 }, //\u795e\u5dde\u5927\u4f17\u53612\n    { 17, 0x3b, 0x9d, 0x95, 0x00, 0x13, 0x61, 0x40, 0x36, 0x13, 0x85, 0xe9,\n        0x44, 0x34, 0x8f, 0x78, 0x8f, 0x4a }, //\u6570\u5b57\u7535\u89c6\u53611\n    { 17, 0x3b, 0x9d, 0x95, 0x00, 0x13, 0x61, 0x40, 0x36, 0x13, 0x85, 0xe9,\n        0x44, 0x34, 0xf3, 0x78, 0x8f, 0x4a }, //\u6570\u5b57\u7535\u89c6\u53612\n    {\n        22, 0x3b, 0x9f, 0x95, 0x80, 0x1f, 0xc3, 0x80,\n        0x31, 0xe0, 0x73, 0xfe, 0x21, 0x13, 0x57, 0x86,\n        0x81, 0x02, 0x86, 0x98, 0x44, 0x18, 0xa8 }, //\u7535\u4fe14G\u5361\n    { 20, 0x3b, 0xfb, 0x94, 0x00, 0x00, 0x80, 0x1f, 0x83, 0x80, 0x65,\n        0x92, 0x10, 0x26, 0x86, 0x53, 0x83, 0x00, 0x90, 0x00, 0xf4 }, //\u8054\u901a\u5361\n    { 16, 0x3b, 0x7b, 0x94, 0x00, 0x00, 0x97, 0x88, 0x84, 0x86, 0x60, 0xa0,\n        0x04, 0x01, 0x00, 0x04, 0x00 }, //\u79fb\u52a8\u5361\n    { 20, 0x3b, 0x7f, 0x12, 0x00, 0x00, 0x44, 0x56, 0x4e, 0x20, 0x54,\n        0x45, 0x53, 0x54, 0x20, 0x43, 0x41, 0x52, 0x44, 0x76, 0x31 } // digital\n    // TV\u5361\n};\n\nuint8_t ic_card_send_cmd[SMART_CARD_NUM][30] = {\n    { 5, 0xe5, 0x04, 0x00, 0x00, 0x04 }, //\u83b1\u897f\u6709\u7ebf\n    { 0 },\n    { 0 },\n    { 0 },\n    { 0 },\n    { 0 },\n    { 0 },\n    { 7, 0xA0, 0xA4, 0x00, 0x00, 0x02, 0x3F, 0x00 }, //\u79fb\u52a8\u5361\n    { 0 }\n};\n\nuint8_t ic_card_rev_data[SMART_CARD_NUM][30] = {\n    { 7, 0x04, 0x4d, 0x33, 0x4f, 0x4b, 0x90, 0x00 }, //\u83b1\u897f\u6709\u7ebf\n    { 0 },\n    { 0 },\n    { 0 },\n    { 0 },\n    { 0 },\n    { 0 },\n    { 3, 0xa4, 0x9f, 0x1b }, //\u79fb\u52a8\u5361\n    { 0 }\n};\n\nscr_struct scr;\nscr_fsm_record scr_fsm;\nscatr_struct scatr;\nupps_struct pps;\n\nextern scr_test_stage stage;\nstatic int state_dly = 0x0;\n\n#define SCR_SIM_DBG(x) pattern_mod_goto(0x2, x)\n\nvoid scr_ccu_clk_gate_on(u32 sel)\n{\n    int ret;\n    ret = readl(0x4003c004);\n    hal_write_reg32(0x4003c004, 0x4000000 | ret);\n}\n\nvoid scr_ccu_clk_gate_off(u32 sel)\n{\n    int ret;\n    ret = readl(0x4003c004);\n    hal_write_reg32(0x4003c004, 0xfbffffff & ret);\n}\n\nvoid scr_module_rst_on(u32 sel)\n{\n    int ret;\n    ret = readl(0x4003c00c);\n    hal_write_reg32(0x4003c00c, 0x4000000 | ret);\n}\n\nvoid scr_module_rst_off(u32 sel)\n{\n    int ret;\n    ret = readl(0x4003c00c);\n    hal_write_reg32(0x4003c00c, 0xfbffffff & ret);\n}\n\nvoid scr_module_rst(u32 sel)\n{\n    scr_module_rst_off(sel);\n    udelay(300);\n    scr_module_rst_on(sel);\n    udelay(300);\n}\n\nvoid scr_pio_setup(void)\n{\n    int ret;\n    ret = hal_gpio_pinmux_set_function(GPIOA(14), 5);\n    if (ret) {\n        printf("scr pin set function failed\\n");\n        return -1;\n    }\n}\n\n/* Configure the CCMU Clock & De-assert Reset & Gating & GPIO configure */\nvoid scr_system_setup(u32 sel)\n{\n    scr_module_rst_off(sel);\n    scr_ccu_clk_gate_off(sel);\n    udelay(300);\n    scr_ccu_clk_gate_on(sel); /*enable APB clock*/\n    scr_module_rst_on(sel);\n    scr_pio_setup(); /*IO configure*/\n}\n\nuint32_t\nscr_reg_test(void) // registers default values cheak and read write check\n{\n    uint32_t temp;\n\n    scr_module_rst(SCR_NO);\n    SCR_TEST_INFO("SCR Register Test Pass!!\\n");\n    return 1;\n}\n\nstatic hal_irqreturn_t scr0_irq_handler(void* dev)\n{\n    scr_handler_irq(&scr);\n\n    return 0;\n}\n\nvoid reg_scr0_irq_handler(void)\n{\n    hal_request_irq(scr.irq_no, scr0_irq_handler, "scr0", &scr);\n    hal_enable_irq(scr.irq_no);\n}\n\nvoid scr_params_init(void)\n{\n    scr.reg_base = 0x40045400;\n\n    scr.irq_no = 69; //\u4e2d\u65ad\u53f7\n    scr.csr_config = CSR_CONFIG_DETPOL | CSR_CONFIG_T | CSR_CONFIG_ATRSTFLUSH | CSR_CONFIG_TSRXEN | CSR_CONFIG_CLKSTPPOL | CSR_CONFIG_PECRXE | CSR_CONFIG_MSBF | CSR_CONFIG_DPOL;\n\n    scr.inten_bm = 0xffffffff; // Enbale all the interrupts\n    scr.txfifo_thh = SCR_FIFO_DEPTH / 2; // set the txfifo trigger level as half full\n    scr.rxfifo_thh = SCR_FIFO_DEPTH / 2; // set the rxfifo trigger level as half full\n    scr.tx_repeat = 0x3; // iso7816\u4e2d\u89c4\u5b9a\u5bf9\u4e8e\u5b58\u5728\u4e89\u8bae\u7684\u5b57\u7b26\uff0c\u6700\u591a\u53ea\u80fd\u91cd\u53d13\u6b21\n    scr.rx_repeat = 0x3; // iso7816\u4e2d\u89c4\u5b9a\u5bf9\u4e8e\u5b58\u5728\u4e89\u8bae\u7684\u5b57\u7b26\uff0c\u6700\u591a\u53ea\u80fd\u91cd\u53d13\u6b21\n\n    scr.scclk_div = (APB2CLK / (2 * SCR_CLK_FRQ)) - 1; // PCLK/12, <175, && SCCLK >= 1M && =<4M\n    scr.baud_div = (scr.scclk_div + 1) * 372 - 1; // ETU = 372*SCCLK\n\n    scr.act_time = 1; // 1*256 clock cycle\n    scr.rst_time = 1; // 1*256 clock cycle\n    scr.atr_time = (35000 >> 8); // 400~40000   \u51b7\u590d\u4f4d\u548c\u70ed\u590d\u4f4d\u65f6,\u5728RST\u62c9\u9ad8\u540e,IO\u8981\u4f5c\u51faATR\u7684\u65f6\u95f4\u9650\u5236\n    scr.guard_time = 2; //=2*ETUs   /* GT = 12etu + R * N/f   ---   Default extra\n        // guard time is 0 */\n    scr.chlimit_time = 9600; // 1024*(10+scr.guard_time); //1K Characters\n    scr.debounce_time = 0xfffff; // insert detect debounce time\n}\n\nvolatile u32 card_name = 0;\nvolatile u32 scr_ret = 0;\nuint32_t scr_test_process(pscr_struct pscr)\n{\n    uint8_t atr_temp[30];\n    uint8_t rsp_temp[30];\n    u32 i = 0;\n    u32 j = 0;\n    uint8_t atr_cmp = 0;\n\n    switch (stage) {\n    case sts_wait_connect:\n        if (scr.detected) /*if detect card, ACT the card*/\n        {\n            state_dly++;\n            if (state_dly >= 50) {\n                msleep(10);\n                scr_start_activation(&scr); /* Activation */\n                stage = sts_wait_act;\n                state_dly = 0;\n            }\n        } else {\n            state_dly = 0;\n        }\n        break;\n    case sts_wait_act:\n        if (scr.activated) {\n            stage = sts_wait_atr;\n        }\n        break;\n    case sts_wait_atr:\n        if (scr.atr_resp != SCR_ATR_RESP_INVALID) {\n            if (scr.atr_resp == SCR_ATR_RESP_OK) /*ATR response is \u6709\u6548\u7684*/\n            {\n                uint32_t i = 0;\n                SCR_TEST_DBG("ATR = ");\n                for (i = 0; i < scr.rxbuf.wptr; i++) {\n                    SCR_TEST_DBG("0x%02x ", *((uint8_t*)(scr.rxbuf.buffer + i)));\n                    atr_temp[i] = *((uint8_t*)(scr.rxbuf.buffer + i));\n                }\n                SCR_TEST_DBG(" \\n");\n                scr.rxbuf.rptr = scr.rxbuf.wptr;\n                smartcard_atr_decode(&scatr, (uint8_t*)scr.rxbuf.buffer, &pps, 1);\n\n                scr_buffer_flush(&scr.rxbuf); // clean rxbuffer\n                stage = sts_start_pps;\n\n                for (i = 0; i < SMART_CARD_NUM; i++) {\n                    u32 atr_length = ic_card_atr[i][0];\n                    for (j = 0; j < atr_length; j++) {\n                        if (atr_temp[j] != ic_card_atr[i][j + 1]) {\n                            break;\n                        }\n                    }\n                    if (j == atr_length) {\n                        card_name = i;\n                        atr_cmp = 1;\n                        break;\n                    } else {\n                        atr_cmp = 0;\n                    }\n                }\n\n                if (atr_cmp) {\n                    printf("crad_name = %d\\n", card_name);\n                    printf("ATR Function PASS!!\\n");\n                } else {\n                    printf("ATR Function FAIL!!\\n");\n                }\n            } else {\n                stage = sts_start_deact;\n            }\n        }\n        break;\n    case sts_start_pps: /* Protocol and parameters selection */\n        pscr->chto_flag = 0;\n        scr_buffer_flush(&scr.rxbuf);\n\n        scr_write_fifo(&scr, pps.ppss);\n        printf("ppss:%x  \\n", pps.ppss);\n        scr_write_fifo(&scr, pps.pps0);\n        printf("pps0:%x  \\n", pps.pps0);\n        if (pps.pps0 & (0x1 << 4)) {\n            scr_write_fifo(&scr, pps.pps1);\n            printf("pps1:%x  \\n", pps.pps1);\n        }\n        if (pps.pps0 & (0x1 << 5)) {\n            scr_write_fifo(&scr, pps.pps2);\n            printf("pps2:%x  \\n", pps.pps2);\n        }\n        if (pps.pps0 & (0x1 << 6)) {\n            scr_write_fifo(&scr, pps.pps3);\n            printf("pps3:%x  \\n", pps.pps3);\n        }\n        scr_write_fifo(&scr, pps.pck);\n        printf("pck:%x  \\n", pps.pck);\n\n        stage = sts_wait_pps_resp;\n        break;\n    case sts_wait_pps_resp: // pps\u4ea4\u6362\u6210\u529f\u7684\u6700\u666e\u901a\u7684\u60c5\u51b5\u5c31\u662f:\u5361\u8bbe\u5907\u7684pps\u8bf7\u6c42\u548cic\u5361\u7684pps\u5e94\u7b54\u7684\u5185\u5bb9\u5b8c\u5168\u4e00\u6837\n        if (pscr->chto_flag) // Wait Data Timeout/*time is too long, time is\n        // out*/\n        {\n            if (scr_buffer_is_empty(&scr.rxbuf)) // RX Buffer, No Response\n            {\n                SCR_TEST_INFO("No PPS Response!!\\n");\n                stage = sts_warm_reset;\n            } else {\n                uint8_t data = scr_dump_buffer(&scr.rxbuf); // read ppss\n                printf("ppss:%x  \\n", data);\n                if (data != pps.ppss) // check ppss\n                {\n                    SCR_TEST_INFO("PPS Resp Start Error: 0x%x !!\\n", data);\n                    break;\n                }\n                if (scr_buffer_is_empty(&scr.rxbuf)) // no pps0\n                {\n                    SCR_TEST_INFO("PPS Resp Too Short 1\\n");\n                    break;\n                }\n                data = scr_dump_buffer(&scr.rxbuf); // read pps0\n                printf("pps0:%x  \\n", data);\n                if (data != pps.pps0) // check pps0\n                {\n                    SCR_TEST_INFO("PPS Resp PPS0 Error: 0x%x vs 0x%x !!\\n", pps.pps0,\n                        data);\n                    break;\n                }\n                if (pps.pps0 & (0x1 << 4)) //\u6839\u636epps0\u7684\u503c,\u6709pps1\n                {\n                    if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pps1\n                    {\n                        SCR_TEST_INFO("PPS Resp Too Short 2\\n");\n                        break;\n                    }\n                    data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pps1\n                    printf("pps1:%x  \\n", data);\n                    if (data != pps.pps1) //\u68c0\u6d4bpps1\n                    {\n                        SCR_TEST_INFO("PPS Resp PPS1 Error: 0x%x vs 0x%x !!\\n", pps.pps1,\n                            data);\n                        break;\n                    }\n                }\n                if (pps.pps0 & (0x1 << 5)) //\u6839\u636epps0\u7684\u503c,\u6709pps2\n                {\n                    if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pps2\n                    {\n                        SCR_TEST_INFO("PPS Resp Too Short 3\\n");\n                        break;\n                    }\n                    data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pps2\n                    printf("pps2:%x  \\n", data);\n                    if (data != pps.pps2) //\u68c0\u6d4bpps2\n                    {\n                        SCR_TEST_INFO("PPS Resp PPS2 Error: 0x%x vs 0x%x !!\\n", pps.pps2,\n                            data);\n                        break;\n                    }\n                }\n                if (pps.pps0 & (0x1 << 6)) //\u6839\u636epps0\u7684\u503c,\u6709pps3\n                {\n                    if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pps3\n                    {\n                        SCR_TEST_INFO("PPS Resp Too Short 4\\n");\n                        break;\n                    }\n                    data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pps3\n                    printf("pps3:%x  \\n", data);\n                    if (data != pps.pps3) //\u68c0\u6d4bpps3\n                    {\n                        SCR_TEST_INFO("PPS Resp PPS3 Error: 0x%x vs 0x%x !!\\n", pps.pps3,\n                            data);\n                        break;\n                    }\n                }\n                if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pck\n                {\n                    SCR_TEST_INFO("PPS Resp Too Short 5\\n");\n                    break;\n                }\n                data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pck\n                printf("pck:%x  \\n", data);\n                if (data != pps.pck) //\u68c0\u6d4bpck\n                {\n                    SCR_TEST_INFO("PPS Resp PCK Error: 0x%x vs 0x%x !!\\n", pps.pck, data);\n                    break;\n                }\n\n                scr_buffer_flush(&scr.rxbuf);\n                stage = sts_send_cmd;\n\n                SCR_TEST_INFO(\n                    "PPS Response OK!!\\n"); //\u5982\u679c\u4e0a\u8ff0if\u4e2d\u90fd\u6ca1\u6709break\u51fa\u6765,\u5219\u8868\u793apps\u4ea4\u6362\u6210\u529f\n\n                scr.baud_div = (scr.scclk_div + 1) * (scatr.F) / (scatr.D) - 1;\n                scr_set_baud_divisor(&scr, pscr->baud_div);\n            }\n        }\n        break;\n\n    case sts_warm_reset:\n        scr.atr_resp = SCR_ATR_RESP_INVALID;\n        scr_start_warmreset(&scr);\n        stage = sts_wait_atr_again;\n        break;\n\n    case sts_wait_atr_again:\n        if (scr.atr_resp != SCR_ATR_RESP_INVALID) {\n            if (scr.atr_resp == SCR_ATR_RESP_OK) /*ATR response is \u6709\u6548\u7684*/\n            {\n                uint32_t i = 0;\n                SCR_TEST_DBG("ATR : ");\n                for (i = 0; i < scr.rxbuf.wptr; i++) {\n                    SCR_TEST_DBG("0x%02x ", *((uint8_t*)(scr.rxbuf.buffer + i)));\n                    atr_temp[i] = *((uint8_t*)(scr.rxbuf.buffer + i));\n                }\n                SCR_TEST_DBG(" \\n");\n                scr.rxbuf.rptr = scr.rxbuf.wptr;\n                smartcard_atr_decode(&scatr, (uint8_t*)scr.rxbuf.buffer, &pps, 1);\n\n                for (i = 0; i < SMART_CARD_NUM; i++) {\n                    u32 atr_length = ic_card_atr[i][0];\n                    for (j = 0; j < atr_length; j++) {\n                        if (atr_temp[j] != ic_card_atr[i][j + 1]) {\n                            break;\n                        }\n                    }\n                    if (j == atr_length) {\n                        card_name = i;\n                        atr_cmp = 1;\n                        break;\n                    } else {\n                        atr_cmp = 0;\n                    }\n                }\n\n                if (atr_cmp) {\n                    printf("crad_name = %d\\n", card_name);\n                    printf("ATR Function PASS!!\\n");\n                } else {\n                    printf("ATR Function FAIL!!\\n");\n                }\n\n                scr.baud_div = (scr.scclk_div + 1) * (scatr.F) / (scatr.D) - 1;\n                scr_set_baud_divisor(&scr, pscr->baud_div);\n\n                scr_buffer_flush(&scr.rxbuf); // clean rxbuffer\n                stage = sts_send_cmd;\n            } else {\n                stage = sts_start_deact;\n            }\n        }\n        break;\n\n    case sts_send_cmd: //\u8fd9\u91cc\u5e94\u8be5\u53ef\u4ee5\u52a0\u5165\u6211\u4eec\u60f3\u8981\u7684\u6c9f\u901a\u547d\u4ee4\n    {\n        uint8_t cmp_rlt = 0;\n        if (ic_card_send_cmd[card_name][0]) {\n            for (i = 0; i < ic_card_send_cmd[card_name][0]; i++) {\n                uint8_t send = ic_card_send_cmd[card_name][i + 1];\n                scr_write_fifo(&scr, send);\n            }\n            msleep(1000);\n            scr_rx_fifo_read(rsp_temp);\n\n            for (i = 0; i < ic_card_rev_data[card_name][0]; i++) {\n                if (rsp_temp[i] != ic_card_rev_data[card_name][i + 1]) {\n                    cmp_rlt = 1;\n                }\n            }\n            if (cmp_rlt) {\n                printf("Communication Command Error: ");\n                for (i = 0; i < ic_card_rev_data[card_name][0]; i++)\n                    printf("0x%02x  ", rsp_temp[i]);\n                printf("\\n");\n                scr_ret++;\n            } else {\n                printf("Communication Command Respone PASS!!\\n");\n            }\n        } else {\n            printf("No communication command, No command test!!\\n");\n            stage = sts_idle;\n        }\n        msleep(1000);\n    } break;\n    case sts_start_deact:\n        stage = sts_wait_deact;\n        scr_start_deactivation(&scr); /* Deactivation */\n        msleep(10);\n        break;\n    case sts_wait_deact:\n        if (!scr.activated) {\n            stage = sts_wait_disconnect;\n            scr_module_rst(SCR_NO);\n            scr_params_init();\n            smartcard_params_init(&scatr); /*set smart card protocol, v,i,frequency*/\n            scr_init(&scr);\n        }\n        break;\n    case sts_wait_disconnect:\n        if (!scr.detected)\n            stage = sts_wait_connect;\n\n        break;\n\n    case sts_idle:\n        msleep(50);\n        if (sts_idle == stage)\n            stage = sts_idle;\n        break;\n    default:\n        stage = sts_idle;\n        break;\n    }\n\n    return 0;\n}\n\nvoid scr_data_transfer_test(void)\n{\n    scr_params_init();\n    scr_init(&scr);\n    reg_scr0_irq_handler();\n    scr_global_interrupt_enable(&scr);\n    while (1)\n        scr_test_process(&scr);\n}\n\n/* s32 scr_test(void) */\nint scr_test1(int argc, char** argv)\n{\n    scr_params_init();\n    /*register default check and read write check*/\n    scr_system_setup(SCR_NO);\n\n    if (scr_reg_test() != 1)\n        return -1;\n\n    /*SCR Control and smart card data transfer test*/\n    scr_system_setup(SCR_NO);\n\n    scr_data_transfer_test();\n\n    return 0;\n}\nFINSH_FUNCTION_EXPORT_CMD(scr_test1, hal_smartcard, smartcard);\n'})})]})}function f(n={}){const{wrapper:r}={...(0,t.a)(),...n.components};return r?(0,s.jsx)(r,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},1151:(n,r,e)=>{e.d(r,{Z:()=>_,a:()=>a});var s=e(7294);const t={},c=s.createContext(t);function a(n){const r=s.useContext(c);return s.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function _(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),s.createElement(c.Provider,{value:r},n.children)}}}]);
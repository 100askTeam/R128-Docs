"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[70],{5397:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>l,contentTitle:()=>_,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=s(5893),t=s(1151);const a={},_="SPI",r={id:"developer-guide/part2/chapter25",title:"SPI",description:"\u6a21\u5757\u529f\u80fd\u4ecb\u7ecd",source:"@site/docs/developer-guide/part2/chapter25.md",sourceDirName:"developer-guide/part2",slug:"/developer-guide/part2/chapter25",permalink:"/en/developer-guide/part2/chapter25",draft:!1,unlisted:!1,editUrl:"https://github.com/100askTeam/R128-Docs/tree/main/docs/developer-guide/part2/chapter25.md",tags:[],version:"current",frontMatter:{},sidebar:"classpartoneSidebar",previous:{title:"USB",permalink:"/en/developer-guide/part2/chapter24"},next:{title:"SPI DBI",permalink:"/en/developer-guide/part2/chapter26"}},l={},d=[{value:"\u6a21\u5757\u529f\u80fd\u4ecb\u7ecd",id:"\u6a21\u5757\u529f\u80fd\u4ecb\u7ecd",level:2},{value:"\u6a21\u5757\u914d\u7f6e\u4ecb\u7ecd",id:"\u6a21\u5757\u914d\u7f6e\u4ecb\u7ecd",level:2},{value:"sys_config\u6587\u4ef6\u5f15\u811a\u914d\u7f6e\u8bf4\u660e",id:"sys_config\u6587\u4ef6\u5f15\u811a\u914d\u7f6e\u8bf4\u660e",level:3},{value:"\u5e73\u53f0\u5934\u6587\u4ef6\u8d44\u6e90\u914d\u7f6e\u8bf4\u660e",id:"\u5e73\u53f0\u5934\u6587\u4ef6\u8d44\u6e90\u914d\u7f6e\u8bf4\u660e",level:3},{value:"menuconfig \u914d\u7f6e\u8bf4\u660e",id:"menuconfig-\u914d\u7f6e\u8bf4\u660e",level:3},{value:"\u6e90\u7801\u7ed3\u6784\u4ecb\u7ecd",id:"\u6e90\u7801\u7ed3\u6784\u4ecb\u7ecd",level:2},{value:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",level:2},{value:"\u91cd\u8981\u7ed3\u6784\u4f53\u53ca\u5b8f\u5b9a\u4e49",id:"\u91cd\u8981\u7ed3\u6784\u4f53\u53ca\u5b8f\u5b9a\u4e49",level:2},{value:"SPI\u6a21\u5f0f\u529f\u80fd\u9009\u62e9",id:"spi\u6a21\u5f0f\u529f\u80fd\u9009\u62e9",level:3},{value:"SPI\u63a7\u5236\u5668\u6a21\u5f0f\u914d\u7f6e",id:"spi\u63a7\u5236\u5668\u6a21\u5f0f\u914d\u7f6e",level:3},{value:"SPI\u63a7\u5236\u5668\u7247\u9009\u6a21\u5f0f",id:"spi\u63a7\u5236\u5668\u7247\u9009\u6a21\u5f0f",level:3},{value:"SPI\u63a7\u5236\u5668\u91c7\u6837\u6a21\u5f0f",id:"spi\u63a7\u5236\u5668\u91c7\u6837\u6a21\u5f0f",level:3},{value:"SPI\u63a7\u5236\u5668\u914d\u7f6e\u7ed3\u6784\u4f53",id:"spi\u63a7\u5236\u5668\u914d\u7f6e\u7ed3\u6784\u4f53",level:3},{value:"SPI\u4f20\u8f93\u7ed3\u6784\u4f53",id:"spi\u4f20\u8f93\u7ed3\u6784\u4f53",level:3},{value:"\u5bf9\u5916\u63d0\u4f9b\u7684API\u63a5\u53e3",id:"\u5bf9\u5916\u63d0\u4f9b\u7684api\u63a5\u53e3",level:2},{value:"hal_spi_init",id:"hal_spi_init",level:3},{value:"hal_spi_deinit",id:"hal_spi_deinit",level:3},{value:"hal_spi_write",id:"hal_spi_write",level:3},{value:"hal_spi_read",id:"hal_spi_read",level:3},{value:"hal_spi_xfer",id:"hal_spi_xfer",level:3},{value:"hal_spi_slave_abort",id:"hal_spi_slave_abort",level:3},{value:"\u6a21\u5757\u4f7f\u7528\u8303\u4f8b",id:"\u6a21\u5757\u4f7f\u7528\u8303\u4f8b",level:2},{value:"Master\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",id:"master\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",level:3},{value:"BIT\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",id:"bit\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",level:3},{value:"\u6d4b\u8bd5\u8303\u4f8b",id:"\u6d4b\u8bd5\u8303\u4f8b",level:3},{value:"Slave\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",id:"slave\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",level:2},{value:"Slave\u6a21\u5f0f\u4f7f\u7528\u8303\u4f8b",id:"slave\u6a21\u5f0f\u4f7f\u7528\u8303\u4f8b",level:3},{value:"Slave \u6a21\u5f0f\u6d4b\u8bd5\u8303\u4f8b",id:"slave-\u6a21\u5f0f\u6d4b\u8bd5\u8303\u4f8b",level:3},{value:"\u8c03\u8bd5\u5de5\u5177",id:"\u8c03\u8bd5\u5de5\u5177",level:2},{value:"FAQ",id:"faq",level:2},{value:"\u591a\u7b14\u6570\u636e\u8fde\u7eed\u53d1\u9001\u65f6\uff0c\u5982\u4f55\u8ba9CS\u811a\u4fdd\u6301\u4f7f\u80fd",id:"\u591a\u7b14\u6570\u636e\u8fde\u7eed\u53d1\u9001\u65f6\u5982\u4f55\u8ba9cs\u811a\u4fdd\u6301\u4f7f\u80fd",level:3}];function c(n){const e={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"spi",children:"SPI"}),"\n",(0,i.jsx)(e.h2,{id:"\u6a21\u5757\u529f\u80fd\u4ecb\u7ecd",children:"\u6a21\u5757\u529f\u80fd\u4ecb\u7ecd"}),"\n",(0,i.jsx)(e.p,{children:"SPI\u662f\u4e00\u79cd\u5168\u53cc\u5de5\u540c\u6b65\u4e32\u884c\u63a5\u53e3\uff0c\u53ef\u4ee5\u5de5\u4f5c\u5728Master\u6a21\u5f0f\u548cSlave\u6a21\u5f0f\uff0cSPI\u4e3b\u8981\u6709\u4ee5\u4e0b\u7279\u70b9\uff1a * \u5168\u53cc\u5de5\u540c\u6b65\u4e32\u884c\u63a5\u53e3 * Master/Slave\u6a21\u5f0f\u53ef\u914d\u7f6e * \u652f\u6301\u6700\u592796MHz\u65f6\u949f\u9891\u7387 * \u652f\u6301SPI Mode0/1/2/3 * \u7247\u9009\u548c\u65f6\u949f\u7684\u6781\u6027\u548c\u76f8\u4f4d\u53ef\u914d\u7f6e * 5\u4e2a\u65f6\u949f\u6e90 * \u652f\u6301\u4e2d\u65ad\u6216DMA\u4f20\u8f93 * \u652f\u6301\u591a\u7247\u9009 * \u652f\u6301Standard Single/Dual/Quad SPI\uff0cFIFO\u6df1\u5ea664B * \u652f\u6301BIT\u6a21\u5f0f\uff0c\u7528\u4e8e3Wire\u573a\u666f\uff0c\u652f\u6301\u53ef\u7f16\u7a0b0~32bits\u5e27\u957f\u5ea6\uff08\u4ec5\u652f\u6301Master\u6a21\u5f0f\uff0c\u4e14\u4e0d\u652f\u6301DMA\u548cFIFO\u529f\u80fd\uff09 * \u652f\u6301DBI\u6a21\u5f0f\uff0c\u7528\u4e8e\u663e\u793a\u8bbe\u5907\u573a\u666f\uff0c\u7528\u4e8e\u4f20\u8f93\u89c6\u9891\u6570\u636e"}),"\n",(0,i.jsx)(e.h2,{id:"\u6a21\u5757\u914d\u7f6e\u4ecb\u7ecd",children:"\u6a21\u5757\u914d\u7f6e\u4ecb\u7ecd"}),"\n",(0,i.jsxs)(e.p,{children:["\u76ee\u524d\u6709\u4e24\u79cd\u65b9\u6cd5\u8fdb\u884c\u5f15\u811a\u914d\u7f6e\uff1a",(0,i.jsx)(e.code,{children:"sys_config"}),"\u548c\u5e73\u53f0\u5934\u6587\u4ef6\u3002"]}),"\n",(0,i.jsxs)(e.p,{children:["\u8fd9\u4e24\u79cd\u65b9\u6cd5\u9009\u5176\u4e2d\u4e00\u79cd\u4f7f\u7528\u5373\u53ef\uff0c\u5728\u6ca1\u6709",(0,i.jsx)(e.code,{children:"sys_config"}),"\u6587\u4ef6\u914d\u7f6e\u65f6\uff0c\u9ed8\u8ba4\u4f7f\u7528\u5e73\u53f0\u5934\u6587\u4ef6\u3002\u5f53\u68c0\u6d4b\u5230\u6709",(0,i.jsx)(e.code,{children:"sys_config"}),"\u6587\u4ef6\u5e76\u6709\u76f8\u5173\u5173\u952e\u5b57\u65f6\uff0c\u81ea\u52a8\u5207\u6362\u4e3a\u8be5\u65b9\u6cd5\u3002"]}),"\n",(0,i.jsx)(e.h3,{id:"sys_config\u6587\u4ef6\u5f15\u811a\u914d\u7f6e\u8bf4\u660e",children:"sys_config\u6587\u4ef6\u5f15\u811a\u914d\u7f6e\u8bf4\u660e"}),"\n",(0,i.jsxs)(e.p,{children:["\u5f15\u811a\u914d\u7f6e\u5728 ",(0,i.jsx)(e.code,{children:"source/project/\u65b9\u6848/configs/sys_config.fex"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"[spi1]\nspi1_used       = 1\nspi1_cs_number  = 1\nspi1_cs_bitmap  = 1\nspi1_cs0        = port:PA02<2><0><2><default>\nspi1_sclk       = port:PA03<2><0><2><default>\nspi1_mosi       = port:PA04<2><0><2><default>\nspi1_miso       = port:PA05<2><0><2><default>\nspi1_hold       = port:PA06<2><0><2><default>\nspi1_wp         = port:PA07<2><0><2><default>\n"})}),"\n",(0,i.jsx)(e.h3,{id:"\u5e73\u53f0\u5934\u6587\u4ef6\u8d44\u6e90\u914d\u7f6e\u8bf4\u660e",children:"\u5e73\u53f0\u5934\u6587\u4ef6\u8d44\u6e90\u914d\u7f6e\u8bf4\u660e"}),"\n",(0,i.jsxs)(e.p,{children:["\u5f15\u811a\u914d\u7f6e\u5728 ",(0,i.jsx)(e.code,{children:"rtos-hal/hal/source/spi/platform/spi_sun20iw2.h"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"static struct sunxi_spi_params_t g_sunxi_spi_params[] = {\n    /* SPI0 */\n    {   .port = 0,\n        .reg_base = SUNXI_SPI0_PBASE, .irq_num = SUNXI_IRQ_SPI0, .gpio_num = 6,\n        .pclk_pll_type = HAL_SUNXI_AON_CCU, .pclk_pll_id = CLK_DEVICE,\n        .pclk_hosc_type = HAL_SUNXI_AON_CCU, .pclk_hosc_id = CLK_HOSC,\n        .bus_type = HAL_SUNXI_CCU, .bus_id = CLK_BUS_SPI0,\n        .mclk_type = HAL_SUNXI_CCU, .mclk_id = CLK_SPI0,\n        .reset_type = HAL_SUNXI_RESET, .reset_id = RST_SPI0,\n        .gpio_clk = GPIOB(6), .gpio_mosi = GPIOB(5), .gpio_miso = GPIOB(15),\n        .gpio_cs0 = GPIOB(4), .gpio_wp = GPIOB(14), .gpio_hold = GPIOB(7),\n        .mux = 4, .driv_level = GPIO_DRIVING_LEVEL2,\n    #ifdef CONFIG_DRIVERS_DMA\n        .drq_tx = DRQDST_SPI0_TX, .drq_rx = DRQSRC_SPI0_RX,\n    #endif\n        .rx_fifosize = 64, .tx_fifosize = 64, .dma_force_fixed = true,\n    },\n    ......\n};\n"})}),"\n",(0,i.jsx)(e.h3,{id:"menuconfig-\u914d\u7f6e\u8bf4\u660e",children:"menuconfig \u914d\u7f6e\u8bf4\u660e"}),"\n",(0,i.jsx)(e.p,{children:"\u914d\u7f6e\u8def\u5f84\u5982\u4e0b\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Kernel Setup  ---\x3e\n    Drivers Setup  ---\x3e\n        SoC HAL Drivers  ---\x3e\n            SPI Devices  ---\x3e\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"http://photos.100ask.net/aw-r128-docs/rtos/developer-guide/part2/chapter25/image1.png",alt:""})}),"\n",(0,i.jsx)(e.h2,{id:"\u6e90\u7801\u7ed3\u6784\u4ecb\u7ecd",children:"\u6e90\u7801\u7ed3\u6784\u4ecb\u7ecd"}),"\n",(0,i.jsx)(e.p,{children:"SPI \u6a21\u5757\u4ee3\u7801\u7ed3\u6784\u5982\u4e0b\u6240\u793a\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"rtos-hal/\n|--include/hal/sunxi_hal_spi.h          // hal\u5c42\u6570\u636e\u7ed3\u6784\u548cAPI\u63a5\u53e3\u76f8\u5173\u5934\u6587\u4ef6\n|--hal/source/spi/platform_spi.h        // hal\u5c42\u5e73\u53f0\u76f8\u5173\u5934\u6587\u4ef6\n|--hal/source/spi/platform/spi_xxx.h    // hal\u5c42\u5e73\u53f0\u4fe1\u606f\u76f8\u5173\u5934\u6587\u4ef6\n|--hal/source/spi/common_spi.h          // hal\u5c42\u63a7\u5236\u5668\u5bc4\u5b58\u5668\u76f8\u5173\u5934\u6587\u4ef6\n|--hal/source/spi/hal_spi.c             // hal\u5c42\u63a5\u53e3\u9a71\u52a8\u4ee3\u7801\n|\n|--hal/test/spi/test_spi.c              // hal\u5c42\u63a5\u53e3\u6d4b\u8bd5\u4ee3\u7801\n|--hal/test/spi/spi_slave_driver.c      // hal\u5c42slave\u6a21\u5f0f\u9a71\u52a8\u4ee3\u7801\n|--hal/test/spi/test_spi_slave.c        // hal\u5c42slave\u6a21\u5f0f\u6d4b\u8bd5\u4ee3\u7801\n"})}),"\n",(0,i.jsx)(e.h2,{id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",children:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e"}),"\n",(0,i.jsx)(e.p,{children:"\u9700\u8981\u5305\u542b\u5934\u6587\u4ef6\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"#include <hal/sunxi_hal_spi.h>\n"})}),"\n",(0,i.jsx)(e.h2,{id:"\u91cd\u8981\u7ed3\u6784\u4f53\u53ca\u5b8f\u5b9a\u4e49",children:"\u91cd\u8981\u7ed3\u6784\u4f53\u53ca\u5b8f\u5b9a\u4e49"}),"\n",(0,i.jsx)(e.h3,{id:"spi\u6a21\u5f0f\u529f\u80fd\u9009\u62e9",children:"SPI\u6a21\u5f0f\u529f\u80fd\u9009\u62e9"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"#define SPI_CPHA        BIT(0)  /* clock phase */\n#define SPI_CPOL        BIT(1)  /* clock polarity */\n\n#define SPI_MODE_0      (0|0)\n#define SPI_MODE_1      (0|SPI_CPHA)\n#define SPI_MODE_2      (SPI_CPOL|0)\n#define SPI_MODE_3      (SPI_CPOL|SPI_CPHA)\n\n#define SPI_CS_HIGH     BIT(2)  /* chipselect active high? */\n#define SPI_LSB_FIRST   BIT(3)  /* per-word bits-on-wire */\n#define SPI_3WIRE       BIT(4)  /* SI/SO signals shared */\n#define SPI_LOOP        BIT(5)  /* loopback mode */\n#define SPI_NO_CS       BIT(6)  /* 1 dev/bus, no chipselect */\n#define SPI_READY       BIT(7)  /* slave pulls low to pause */\n#define SPI_TX_DUAL     BIT(8)  /* transmit with 2 wires */\n#define SPI_TX_QUAD     BIT(9)  /* transmit with 4 wires */\n#define SPI_RX_DUAL     BIT(10) /* receive with 2 wires */\n#define SPI_RX_QUAD     BIT(11) /* receive with 4 wires */\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"SPI_MODE_0/1/2/3\uff1a\u8bbe\u7f6eSPI\u7684\u4f20\u8f93\u6a21\u5f0f\u3002"}),"\n",(0,i.jsx)(e.li,{children:"SPI_CS_HIGH\uff1a\u8bbe\u7f6eCS\u7247\u9009\u662f\u5426\u4e3a\u9ad8\u7535\u5e73\u6709\u6548\u3002"}),"\n",(0,i.jsx)(e.li,{children:"SPI_LSB_FIRST\uff1a\u8bbe\u7f6e\u53d1\u9001\u987a\u5e8f\u662f\u4f4e\u4f4d\u5728\u524d\u3002"}),"\n",(0,i.jsx)(e.li,{children:"SPI_3WIRE\uff1a\u8bbe\u7f6eSPI\u5de5\u4f5c\u57283\u7ebf\u6a21\u5f0f\u4e0b\uff0c\u53caMOSI\u5373\u7528\u4f5c\u8f93\u5165\u4e5f\u7528\u4f5c\u8f93\u5165\uff0c\u5b9e\u73b0\u534a\u53cc\u5de5\u901a\u4fe1"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"spi\u63a7\u5236\u5668\u6a21\u5f0f\u914d\u7f6e",children:"SPI\u63a7\u5236\u5668\u6a21\u5f0f\u914d\u7f6e"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"typedef enum\n{\n    HAL_SPI_BUS_MASTER = 0,\n    HAL_SPI_BUS_SLAVE = 1,\n    HAL_SPI_BUS_BIT = 2,\n} hal_spi_master_bus_mode_t;\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"HAL_SPI_BUS_MASTER\uff1a\u5904\u4e8eMaster\u6a21\u5f0f\uff0c\u5916\u63a5SPI Device\u3002"}),"\n",(0,i.jsx)(e.li,{children:"HAL_SPI_BUS_SLAVE\uff1a\u5904\u4e8eSlave\u6a21\u5f0f\uff0c\u88ab\u5176\u4ed6Master\u8bbf\u95ee\u3002"}),"\n",(0,i.jsx)(e.li,{children:"HAL_SPI_BUS_BIT\uff1a\u5904\u4e8eBIT\u6a21\u5f0f\uff0c\u4f7f\u75283Wire\u65b9\u5f0f\u8fdb\u884c\u6570\u636e\u4f20\u8f93\u3002"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"spi\u63a7\u5236\u5668\u7247\u9009\u6a21\u5f0f",children:"SPI\u63a7\u5236\u5668\u7247\u9009\u6a21\u5f0f"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"typedef enum\n{\n    HAL_SPI_CS_AUTO = 0,\n    HAL_SPI_CS_SOFT = 1,\n} hal_spi_master_cs_mode_t;\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"HAL_SPI_CS_AUTO\uff1a\u786c\u4ef6\u81ea\u52a8\u63a7\u5236\uff0c\u4e0d\u9700\u8981\u9a71\u52a8\u6216\u8f6f\u4ef6\u4ecb\u5165\u3002"}),"\n",(0,i.jsx)(e.li,{children:"HAL_SPI_CS_SOFT\uff1a\u8f6f\u4ef6\u624b\u52a8\u63a7\u5236\uff0c\u7531\u9a71\u52a8\u5b8c\u6210\u76f8\u5173\u64cd\u4f5c\u3002"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"spi\u63a7\u5236\u5668\u91c7\u6837\u6a21\u5f0f",children:"SPI\u63a7\u5236\u5668\u91c7\u6837\u6a21\u5f0f"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"typedef enum\n{\n    SUNXI_SPI_SAMP_MODE_OLD = 0,\n    SUNXI_SPI_SAMP_MODE_NEW = 1,\n} hal_spi_master_bus_sample_mode_t;\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"SUNXI_SPI_SAMP_MODE_OLD\uff1a\u7c97\u8c03\u6a21\u5f0f\uff0c\u5171\u67093\u6863\u53ef\u8c03"}),"\n",(0,i.jsx)(e.li,{children:"SUNXI_SPI_SAMP_MODE_NEW\uff1a\u7ec6\u8c03\u6a21\u5f0f\uff0c\u5171\u67097\u6863\u53ef\u8c03"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"\u7c97\u8c03\u6a21\u5f0f\u4e3a\u9a71\u52a8\u6839\u636e\u65f6\u949f\u9891\u7387\u81ea\u52a8\u8bc6\u522b\uff0c\u4e0d\u9700\u8981\u989d\u5916\u914d\u7f6e"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"typedef enum\n{\n    SUNXI_SPI_SAMP_DELAY_CYCLE_0_0 = 0,\n    SUNXI_SPI_SAMP_DELAY_CYCLE_0_5 = 1,\n    SUNXI_SPI_SAMP_DELAY_CYCLE_1_0 = 2,\n    SUNXI_SPI_SAMP_DELAY_CYCLE_1_5 = 3,\n    SUNXI_SPI_SAMP_DELAY_CYCLE_2_0 = 4,\n    SUNXI_SPI_SAMP_DELAY_CYCLE_2_5 = 5,\n    SUNXI_SPI_SAMP_DELAY_CYCLE_3_0 = 6,\n} hal_spi_master_spi_sample_mode_t;\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"SUNXI_SPI_SAMP_DELAY_CYCLE\uff1a\u91c7\u6837\u5ef6\u65f6\u8c03\u8282\u6321\u4f4d\u9009\u62e9"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"\u5f53\u91c7\u6837\u6a21\u5f0f\u5904\u4e8e\u7ec6\u8c03\u65f6\uff0c\u624d\u4f1a\u4f7f\u7528\u5230\u8be5\u53c2\u6570"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"spi\u63a7\u5236\u5668\u914d\u7f6e\u7ed3\u6784\u4f53",children:"SPI\u63a7\u5236\u5668\u914d\u7f6e\u7ed3\u6784\u4f53"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"typedef struct\n{\n    hal_spi_master_bus_mode_t bus_mode; // SPI\u63a7\u5236\u5668\u914d\u7f6e\n    hal_spi_master_cs_mode_t cs_mode;   // SPI\u63a7\u5236\u5668\u7247\u9009\u6a21\u5f0f\n    hal_spi_master_bus_sample_mode_t bus_sample_mode;   // SPI\u63a7\u5236\u5668\u91c7\u6837\u6a21\u5f0f - \u7c97\u8c03\n    hal_spi_master_spi_sample_mode_t spi_sample_mode;   // SPI\u63a7\u5236\u5668\u91c7\u6837\u6a21\u5f0f - \u7ec6\u8c03\n    uint32_t spi_sample_delay;  // SPI\u63a7\u5236\u5668\u7ec6\u8c03\u91c7\u6837\u5ef6\u65f6\n    uint8_t chipselect; /* SPI slave device selection */\n    uint32_t clock_frequency; /* SPI master clock frequency setting */\n    uint32_t mode;  // SPI\u6a21\u5f0f/\u529f\u80fd\u9009\u62e9\n    bool sip;\n    bool flash;\n} hal_spi_master_config_t;\n"})}),"\n",(0,i.jsx)(e.h3,{id:"spi\u4f20\u8f93\u7ed3\u6784\u4f53",children:"SPI\u4f20\u8f93\u7ed3\u6784\u4f53"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"typedef struct\n{\n    const uint8_t *tx_buf;  /* Data buffer to send */\n    uint32_t tx_len;        /* The total number of bytes to send */\n    uint32_t tx_single_len; /* The number of bytes to send in single mode */\n    uint8_t *rx_buf;        /* Received data buffer, */\n    uint32_t rx_len;        /* The valid number of bytes received */\n    uint8_t tx_nbits : 3;   /* Data buffer to send in nbits mode */\n    uint8_t rx_nbits : 3;   /* Data buffer to received in nbits mode */\n    uint8_t dummy_byte;     /* Flash send dummy byte, default 0*/\n#define SPI_NBITS_SINGLE    0x01 /* 1bit transfer */\n#define SPI_NBITS_DUAL      0x02 /* 2bits transfer */\n#define SPI_NBITS_QUAD      0x04 /* 4bits transfer */\n    uint8_t bits_per_word;  /* transfer bit_per_word */\n} hal_spi_master_transfer_t;\n"})}),"\n",(0,i.jsx)(e.h2,{id:"\u5bf9\u5916\u63d0\u4f9b\u7684api\u63a5\u53e3",children:"\u5bf9\u5916\u63d0\u4f9b\u7684API\u63a5\u53e3"}),"\n",(0,i.jsx)(e.h3,{id:"hal_spi_init",children:"hal_spi_init"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u539f\u578b:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_status_t hal_spi_init(int port, hal_spi_master_config_t *cfg)\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528\uff1aSPI\u6a21\u5757\u521d\u59cb\u5316\uff0c\u4e3b\u8981\u7533\u8bf7\u4e2d\u65ad\u3001pinctrl\u521d\u59cb\u5316\u3001clk\u521d\u59cb\u5316\u3001SPI\u6a21\u5757\uff0c\u5305\u62ecSPI\u603b\u7ebf\u6700\u5927\u4f20\u8f93\u901f\u7387\u3001\u7247\u9009\u6a21\u5f0f\u7b49\u7b49"}),"\n",(0,i.jsxs)(e.li,{children:["\u53c2\u6570\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["port",":SPI","\u7aef\u53e3\u53f7"]}),"\n",(0,i.jsx)(e.li,{children:"cfg:\u914d\u7f6e\u4fe1\u606f"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u8fd4\u56de\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"0:\u6210\u529f"}),"\n",(0,i.jsx)(e.li,{children:"\u8d1f\u6570:\u5931\u8d25"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"hal_spi_deinit",children:"hal_spi_deinit"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u539f\u578b:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_status_t hal_spi_deinit(int port)\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528\uff1aSPI\u6a21\u5757\u53bb\u521d\u59cb\u5316"}),"\n",(0,i.jsxs)(e.li,{children:["\u53c2\u6570\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["port",":SPI","\u7aef\u53e3\u53f7"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u8fd4\u56de\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"0:\u6210\u529f"}),"\n",(0,i.jsx)(e.li,{children:"\u8d1f\u6570:\u5931\u8d25"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"hal_spi_write",children:"hal_spi_write"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u539f\u578b:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_status_t hal_spi_write(int port, const uint8_t *buf, uint32_t size)\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528\uff1a\u53d1\u9001\u6570\u636e\uff0c\u8c03hal_spi_xfer\u63a5\u53e3"}),"\n",(0,i.jsxs)(e.li,{children:["\u53c2\u6570\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["port",":SPI","\u7aef\u53e3\u53f7"]}),"\n",(0,i.jsx)(e.li,{children:"buf:\u53d1\u9001\u6570\u636e"}),"\n",(0,i.jsx)(e.li,{children:"size:\u53d1\u9001\u6570\u636e\u5927\u5c0f"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u8fd4\u56de\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"0:\u6210\u529f"}),"\n",(0,i.jsx)(e.li,{children:"\u8d1f\u6570:\u5931\u8d25"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"hal_spi_read",children:"hal_spi_read"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u539f\u578b:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_status_t hal_spi_read(int port, uint8_t *buf, uint32_t size)\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528\uff1a\u63a5\u6536\u6570\u636e\uff0c\u8c03hal_spi_xfer\u63a5\u53e3"}),"\n",(0,i.jsxs)(e.li,{children:["\u53c2\u6570\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["port",":SPI","\u7aef\u53e3\u53f7"]}),"\n",(0,i.jsx)(e.li,{children:"buf:\u63a5\u6536\u6570\u636e"}),"\n",(0,i.jsx)(e.li,{children:"size:\u63a5\u6536\u6570\u636e\u5927\u5c0f"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u8fd4\u56de\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"0:\u6210\u529f"}),"\n",(0,i.jsx)(e.li,{children:"\u8d1f\u6570:\u5931\u8d25"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"hal_spi_xfer",children:"hal_spi_xfer"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u539f\u578b:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_status_t hal_spi_xfer(int port, hal_spi_master_transfer_t *t, int num)\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528\uff1a\u53d1\u9001\u6216\u63a5\u6536\u6570\u636e"}),"\n",(0,i.jsxs)(e.li,{children:["\u53c2\u6570\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["port",":SPI","\u7aef\u53e3\u53f7"]}),"\n",(0,i.jsx)(e.li,{children:"t:\u6307\u5411\u4f20\u8f93\u5305\u5934\u7684\u6307\u9488"}),"\n",(0,i.jsx)(e.li,{children:"num:\u4f20\u8f93\u5305\u7684\u4e2a\u6570"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u8fd4\u56de\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"0:\u6210\u529f"}),"\n",(0,i.jsx)(e.li,{children:"\u8d1f\u6570:\u5931\u8d25"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"hal_spi_slave_abort",children:"hal_spi_slave_abort"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u539f\u578b:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_status_t hal_spi_slave_abort(int port)\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528\uff1a\u7ec8\u6b62slave\u6a21\u5f0f\u4f20\u8f93"}),"\n",(0,i.jsxs)(e.li,{children:["\u53c2\u6570\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["port",":SPI","\u7aef\u53e3\u53f7"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u8fd4\u56de\uff1a","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"0:\u6210\u529f"}),"\n",(0,i.jsx)(e.li,{children:"\u8d1f\u6570:\u5931\u8d25"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"\u6a21\u5757\u4f7f\u7528\u8303\u4f8b",children:"\u6a21\u5757\u4f7f\u7528\u8303\u4f8b"}),"\n",(0,i.jsx)(e.h3,{id:"master\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",children:"Master\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_config_t cfg = { 0 };\ncfg.bus_mode = HAL_SPI_BUS_MASTER;\ncfg.cs_mode = HAL_SPI_CS_AUTO;\ncfg.clock_frequency = 10000000;\ncfg.chipselect = 0;\ncfg.mode = SPI_MODE_0;\ncfg.sip = 0;\ncfg.flash = 0;\nhal_spi_init(port, &cfg);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"bit\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",children:"BIT\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_config_t cfg = { 0 };\ncfg.bus_mode = HAL_SPI_BUS_BIT;\n......\nhal_spi_init(port, &cfg);\n\nhal_spi_master_transfer_t tr = {\n    .tx_buf = &buf,\n    .tx_len = 1,\n    .rx_buf = NULL,\n    .rx_len = 0,\n    .bits_per_word = 8,\n};\nhal_spi_xfer(port, tr, 1);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"\u6d4b\u8bd5\u8303\u4f8b",children:"\u6d4b\u8bd5\u8303\u4f8b"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <getopt.h>\n#include <sys/time.h>\n\n#include <hal_log.h>\n#include <hal_cmd.h>\n#include <hal_mem.h>\n#include <hal_timer.h>\n#include <sunxi_hal_spi.h>\n\n#define KB (1024)\n#define MB (1024*KB)\n#define US (1)\n#define MS (1000*US)\n#define S  (1000*MS)\n\nstatic void pabort(const char *s)\n{\n    if (errno != 0)\n        perror(s);\n    else\n        hal_log_err("%s\\n", s);\n\n    abort();\n}\n\nstatic int port = 1;\nstatic uint32_t mode;\nstatic uint8_t bits = 8;\nstatic uint32_t speed = 5000000;\nstatic int verbose;\nstatic int transfer_size;\nstatic int iterations;\n\nstatic uint8_t default_tx[] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0x40, 0x00, 0x00, 0x00, 0x00, 0x95,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xF0, 0x0D,\n};\n\nstatic uint8_t default_rx[sizeof(default_tx)];\nstatic char *input_tx;\n\nstatic void hex_dump(const void *src, size_t length, size_t line_size,\n             char *prefix)\n{\n    int i = 0;\n    const unsigned char *address = src;\n    const unsigned char *line = address;\n    unsigned char c;\n\n    printf("%s | ", prefix);\n    while (length-- > 0) {\n        printf("%02X ", *address++);\n        if (!(++i % line_size) || (length == 0 && i % line_size)) {\n            if (length == 0) {\n                while (i++ % line_size)\n                    printf("__ ");\n            }\n            printf(" |");\n            while (line < address) {\n                c = *line++;\n                printf("%c", (c < 32 || c > 126) ? \'.\' : c);\n            }\n            printf("|\\n");\n            if (length > 0)\n                printf("%s | ", prefix);\n        }\n    }\n}\n\n/*\n *  Unescape - process hexadecimal escape character\n *      converts shell input "\\x23" -> 0x23\n */\nstatic int unescape(char *_dst, char *_src, size_t len)\n{\n    int ret = 0;\n    int match;\n    char *src = _src;\n    char *dst = _dst;\n    unsigned int ch;\n\n    while (*src) {\n        if (*src == \'\\\\\' && *(src+1) == \'x\') {\n            match = sscanf(src + 2, "%2x", &ch);\n            if (!match)\n                pabort("malformed input string");\n\n            src += 4;\n            *dst++ = (unsigned char)ch;\n        } else {\n            *dst++ = *src++;\n        }\n        ret++;\n    }\n    return ret;\n}\n\nstatic unsigned long transfer(int port, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n    hal_spi_master_status_t ret = 0;\n    unsigned long usec = 0;\n    struct timeval start, end;\n    hal_spi_master_transfer_t tr = {\n        .tx_buf = (uint8_t *)tx,\n        .tx_len = len,\n        .rx_buf = (uint8_t *)rx,\n        .rx_len = len,\n        .tx_single_len = len,\n        .dummy_byte = 0,\n        .bits_per_word = bits,\n    };\n\n    if (mode & SPI_TX_QUAD)\n        tr.tx_nbits = 4;\n    else if (mode & SPI_TX_DUAL)\n        tr.tx_nbits = 2;\n    else if (mode & SPI_RX_QUAD)\n        tr.rx_nbits = 4;\n    else if (mode & SPI_RX_DUAL)\n        tr.rx_nbits = 2;\n    if (!(mode & SPI_LOOP)) {\n        if (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n            tr.rx_buf = 0;\n        else if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n            tr.tx_buf = 0;\n        else if (mode & SPI_3WIRE)\n            tr.rx_buf = 0;\n    }\n\n    gettimeofday(&start, NULL);\n    ret = hal_spi_xfer(port, &tr, 1);\n    gettimeofday(&end, NULL);\n    if (ret < 0)\n        pabort("can\'t send spi message");\n\n    if (verbose)\n    {\n        hex_dump(tx, len, 32, "TX");\n        hex_dump(rx, len, 32, "RX");\n    }\n\n    if (memcmp(tx, rx, len))\n        hal_log_info("rx/tx buffer is not same, data error!!!\\n");\n\n    usec = (1000000 * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec);\n    return usec;\n}\n\nstatic void print_usage(const char *prog)\n{\n    hal_log_info("Usage: %s [-DsblHOLC3vpNR24SI]\\n", prog);\n    puts("  -D --device   device port to use (default 1)\\n"\n         "  -s --speed    max speed (Hz)\\n"\n         "  -b --bpw      bits per word\\n"\n         "  -l --loop     loopback\\n"\n         "  -H --cpha     clock phase\\n"\n         "  -O --cpol     clock polarity\\n"\n         "  -L --lsb      least significant bit first\\n"\n         "  -C --cs-high  chip select active high\\n"\n         "  -3 --3wire    SI/SO signals shared\\n"\n         "  -v --verbose  Verbose (show tx buffer)\\n"\n         "  -p            Send data (e.g. \\"1234\\\\xde\\\\xad\\")\\n"\n         "  -N --no-cs    no chip select\\n"\n         "  -R --ready    slave pulls low to pause\\n"\n         "  -2 --dual     dual transfer\\n"\n         "  -4 --quad     quad transfer\\n"\n         "  -S --size     transfer size\\n"\n         "  -I --iter     iterations\\n");\n}\n\nstatic int parse_opts(int argc, char *argv[])\n{\n    int ret = 0;\n\n    while (1) {\n        static const struct option lopts[] = {\n            { "device",  1, 0, \'D\' },\n            { "speed",   1, 0, \'s\' },\n            { "bpw",     1, 0, \'b\' },\n            { "loop",    0, 0, \'l\' },\n            { "cpha",    0, 0, \'H\' },\n            { "cpol",    0, 0, \'O\' },\n            { "lsb",     0, 0, \'L\' },\n            { "cs-high", 0, 0, \'C\' },\n            { "3wire",   0, 0, \'3\' },\n            { "no-cs",   0, 0, \'N\' },\n            { "ready",   0, 0, \'R\' },\n            { "dual",    0, 0, \'2\' },\n            { "verbose", 0, 0, \'v\' },\n            { "quad",    0, 0, \'4\' },\n            { "size",    1, 0, \'S\' },\n            { "iter",    1, 0, \'I\' },\n            { NULL, 0, 0, 0 },\n        };\n        int c;\n\n        c = getopt_long(argc, argv, "D:s:b:lHOLC3NR24p:vS:I:",\n                lopts, NULL);\n\n        if (c == -1)\n            break;\n\n        switch (c) {\n        case \'D\':\n            port = atoi(optarg);\n            break;\n        case \'s\':\n            speed = atoi(optarg);\n            break;\n        case \'b\':\n            bits = atoi(optarg);\n            break;\n        case \'l\':\n            mode |= SPI_LOOP;\n            break;\n        case \'H\':\n            mode |= SPI_CPHA;\n            break;\n        case \'O\':\n            mode |= SPI_CPOL;\n            break;\n        case \'L\':\n            mode |= SPI_LSB_FIRST;\n            break;\n        case \'C\':\n            mode |= SPI_CS_HIGH;\n            break;\n        case \'3\':\n            mode |= SPI_3WIRE;\n            break;\n        case \'N\':\n            mode |= SPI_NO_CS;\n            break;\n        case \'v\':\n            verbose = 1;\n            break;\n        case \'R\':\n            mode |= SPI_READY;\n            break;\n        case \'p\':\n            input_tx = optarg;\n            break;\n        case \'2\':\n            mode |= SPI_TX_DUAL;\n            break;\n        case \'4\':\n            mode |= SPI_TX_QUAD;\n            break;\n        case \'S\':\n            transfer_size = atoi(optarg);\n            break;\n        case \'I\':\n            iterations = atoi(optarg);\n            break;\n        default:\n            print_usage(argv[0]);\n            ret = -1;\n        }\n    }\n    if (mode & SPI_LOOP) {\n        if (mode & SPI_TX_DUAL)\n            mode |= SPI_RX_DUAL;\n        if (mode & SPI_TX_QUAD)\n            mode |= SPI_RX_QUAD;\n    }\n\n    return ret;\n}\n\nstatic void transfer_escaped_string(int port, char *str)\n{\n    size_t size = strlen(str);\n    uint8_t *tx;\n    uint8_t *rx;\n\n    tx = hal_malloc(size);\n    if (!tx)\n        pabort("can\'t allocate tx buffer");\n\n    rx = hal_malloc(size);\n    if (!rx)\n        pabort("can\'t allocate rx buffer");\n\n    size = unescape((char *)tx, str, size);\n    transfer(port, tx, rx, size);\n    hal_free(rx);\n    hal_free(tx);\n}\n\nstatic void show_transfer_info(unsigned long size, unsigned long time)\n{\n    double rate;\n\n    printf("total size   : ");\n    if (size >= MB) {\n        printf("%.2lf MB", (double)size/(double)MB);\n    } else if (size >= KB) {\n        printf("%.2lf KB", (double)size/(double)KB);\n    } else {\n        printf("%lu B", size);\n    }\n    printf("\\n");\n\n    printf("total time   : ");\n    if (time >= S) {\n        printf("%.2lf s", (double)time/(double)S);\n    } else if (time >= MS) {\n        printf("%.2lf ms", (double)time/(double)MS);\n    } else {\n        printf("%.2lf us", (double)time/(double)US);\n    }\n    printf("\\n");\n\n    rate = ((double)size / (double)MB) / ((double)time / (double)S);\n    printf("averange rate: %.2lf MB/s\\n", rate);\n}\n\nstatic unsigned long transfer_buf(int port, int len)\n{\n    uint8_t *tx;\n    uint8_t *rx;\n    int i;\n    unsigned long usec = 0;\n\n    tx = hal_malloc(len);\n    if (!tx)\n        pabort("can\'t allocate tx buffer");\n\n    srand(time(NULL));\n    for (i = 0; i < len; i++)\n        tx[i] = random();\n\n    rx = hal_malloc(len);\n    if (!rx)\n        pabort("can\'t allocate rx buffer");\n\n    usec = transfer(port, tx, rx, len);\n\n    if (mode & SPI_LOOP) {\n        if (memcmp(tx, rx, len)) {\n            fprintf(stderr, "transfer error !\\n");\n            hex_dump(tx, len, 32, "TX");\n            hex_dump(rx, len, 32, "RX");\n            exit(1);\n        }\n    }\n\n    hal_free(rx);\n    hal_free(tx);\n\n    return usec;\n}\n\nstatic int cmd_spidev_test(int argc, char **argv)\n{\n    hal_spi_master_config_t cfg = { 0 };\n\n    port = 1;\n    mode = 0;\n    bits = 8;\n    speed = 5000000;\n    verbose = 0;\n    transfer_size = 0;\n    iterations = 0;\n    input_tx = NULL;\n    memset(default_rx, 0, sizeof(default_rx));\n\n    if (parse_opts(argc, argv) < 0) {\n        return 0;\n    }\n\n    if (mode & SPI_3WIRE)\n        cfg.bus_mode = HAL_SPI_BUS_BIT;\n    else\n        cfg.bus_mode = HAL_SPI_BUS_MASTER;\n    cfg.cs_mode = HAL_SPI_CS_AUTO;\n    cfg.clock_frequency = speed;\n    cfg.chipselect = 0;\n    cfg.mode = mode;\n    cfg.sip = 0;\n    cfg.flash = 0;\n    hal_spi_init(port, &cfg);\n\n    hal_log_info("spi mode: 0x%x\\n", mode);\n    hal_log_info("bits per word: %u\\n", bits);\n    hal_log_info("max speed: %u Hz (%u kHz)\\n", speed, speed/1000);\n\n    if (input_tx)\n        transfer_escaped_string(port, input_tx);\n    else if (transfer_size) {\n        unsigned long total_size = transfer_size * iterations;\n        unsigned long total_usec = 0;\n        int i;\n\n        for (i = 0; i < iterations; i++)\n            total_usec += transfer_buf(port, transfer_size);\n\n        show_transfer_info(total_size, total_usec);\n        printf("averange time: %.2lf us\\n", (double)total_usec/(double)(iterations));\n    } else\n        transfer(port, default_tx, default_rx, sizeof(default_tx));\n\n    hal_spi_deinit(port);\n\n    return 0;\n}\n\nFINSH_FUNCTION_EXPORT_CMD(cmd_spidev_test, hal_spidev_test, spidev hal APIs tests)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"slave\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b",children:"Slave\u6a21\u5f0f\u4f7f\u7528\u53ca\u6d4b\u8bd5\u8303\u4f8b"}),"\n",(0,i.jsx)(e.h3,{id:"slave\u6a21\u5f0f\u4f7f\u7528\u8303\u4f8b",children:"Slave\u6a21\u5f0f\u4f7f\u7528\u8303\u4f8b"}),"\n",(0,i.jsx)(e.p,{children:"\u91cd\u70b9\u4ee3\u7801\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'hal_spi_master_config_t cfg = { 0 };\ncfg.bus_mode = HAL_SPI_BUS_SLAVE;\ncfg.clock_frequency = 10000000;\ncfg.chipselect = 0;\ncfg.mode = SPI_MODE_0;\nhal_spi_init(port, &cfg);\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/time.h>\n\n#include <hal_log.h>\n#include <hal_cmd.h>\n#include <hal_mem.h>\n#include <hal_timer.h>\n#include <hal_thread.h>\n#include <sunxi_hal_spi.h>\n#include <platform_spi.h>\n\n#ifdef CONFIG_ARCH_SUN20IW2\n#define SPI_SLAVE_THREAD_STACK_SIZE 4096\n#else\n#define SPI_SLAVE_THREAD_STACK_SIZE 8192\n#endif\n\n#define SLAVE_CACHE_MAX (4096)\n\n#define PKT_HEAD_LEN 5\n#define OP_MASK     0\n#define ADDR_MASK_0 1\n#define ADDR_MASK_1 2\n#define LEN_MASK_0  3\n#define LEN_MASK_1  4\n\n#define SUNXI_OP_WRITE  0x01\n#define SUNXI_OP_READ   0x03\n#define SUNXI_OP_HEAD   0xff\n\nenum sunxi_spi_slave_status {\n    SUNXI_SPI_SLAVE_NONE = 0,\n    SUNXI_SPI_SLAVE_RUNNING,\n    SUNXI_SPI_SLAVE_RETRY,\n    SUNXI_SPI_SLAVE_STOP,\n};\n\nstruct sunxi_spi_slave_head {\n    u8 op_code;\n    u16 addr;\n    u16 len;\n};\n\nstruct sunxi_spi_slave_frame {\n    u8 data[PKT_HEAD_LEN];\n    struct sunxi_spi_slave_head pkt_head;\n    u8 *tx_buf;\n    u8 *rx_buf;\n};\n\nstruct sunxi_spi_slave_cache {\n    hal_spinlock_t buffer_lock;\n    u8 *buffer;\n    u32 size;\n};\n\nstruct sunxi_spi_slave_test {\n    int  port;\n    hal_spi_master_config_t cfg;\n    hal_sem_t semaphore_finished;\n    hal_spi_master_transfer_t xfer;\n    struct sunxi_spi_slave_frame frame;\n    struct sunxi_spi_slave_cache cache;\n    enum sunxi_spi_slave_status status;\n    hal_thread_t thread_handle;\n    char task_name[256];\n};\n\nstatic struct sunxi_spi_slave_test spi_slave_test[HAL_SPI_MASTER_MAX];\n\nstatic bool sunxi_spi_dump_data(const uint8_t *buf, uint32_t offset, uint32_t len)\n{\n    int col = 16;\n    int line = len / col;\n    int last = len % col;\n    int i, j;\n    uint8_t *buffer = (int8_t *)buf + offset;\n\n    for (i = 0; i < line; i++) {\n        printf("%08X: ", i + offset);\n        for (j = 0; j < col; j++) {\n            printf("%02x ", buffer[col * i + j]);\n        }\n        printf("\\n");\n    }\n\n    printf("%08X: ", col * line + offset);\n    for (j = 0; j < last; j++) {\n        printf("%02x ", buffer[col * line + j]);\n    }\n    printf("\\n");\n}\n\nint sunxi_spi_init_slave_data(struct sunxi_spi_slave_test *slave, u8 pattern)\n{\n    memset(slave->cache.buffer, pattern, slave->cache.size);\n    return 0;\n}\n\nstatic bool sunxi_spi_slave_has_ptk_head(struct sunxi_spi_slave_head *head)\n{\n    if (head->op_code || head->addr || head->len)\n        return true;\n\n    return false;\n}\n\nstatic void sunxi_spi_slave_head_data_parse(unsigned char *data, struct sunxi_spi_slave_head *head)\n{\n    head->op_code = data[OP_MASK];\n    head->addr = (data[ADDR_MASK_0] << 8) | data[ADDR_MASK_1];\n    head->len = (data[LEN_MASK_0] << 8) | data[LEN_MASK_1];\n}\n\nstatic void sunxi_spi_slave_head_data_clear(unsigned char *data, int len)\n{\n    memset(data, 0, len);\n}\n\nstatic int sunxi_spi_slave_set_cache_data(struct sunxi_spi_slave_test *slave,\n                                    struct sunxi_spi_slave_head *head, u8 *buf)\n{\n    struct sunxi_spi_slave_cache *cache = &slave->cache;\n    int real_size = head->len;\n\n    if (cache->size < head->addr) {\n        hal_log_err("Set data addr over range");\n        return 0;\n    }\n\n    if (cache->size < head->addr + head->len) {\n        real_size = cache->size - head->addr;\n        hal_log_err("Write size %d over range, some of data will be lost, real size to write is %d",\n                head->len, real_size);\n    }\n\n    hal_spin_lock(&cache->buffer_lock);\n    memcpy(cache->buffer + head->addr, buf, real_size);\n    hal_spin_unlock(&cache->buffer_lock);\n\n    return 0;\n}\n\nstatic int sunxi_spi_slave_get_cache_data(struct sunxi_spi_slave_test *slave,\n                                        struct sunxi_spi_slave_head *head, u8 *buf)\n{\n    struct sunxi_spi_slave_cache *cache = &slave->cache;\n    int real_size = head->len;\n\n    if (cache->size < head->addr) {\n        hal_log_err("Get data addr over range");\n        return 0;\n    }\n\n    if (cache->size < head->addr + head->len) {\n        real_size = cache->size - head->addr;\n        hal_log_err("Read size %d over range, some of data will be lost, real size to read is %d",\n            head->len, real_size);\n    }\n\n    hal_spin_lock(&cache->buffer_lock);\n    memcpy(buf, cache->buffer + head->addr, real_size);\n    hal_spin_unlock(&cache->buffer_lock);\n\n    return 0;\n}\n\nstatic int sunxi_spi_slave_test_submit(struct sunxi_spi_slave_test *slave)\n{\n    struct sunxi_spi_slave_head *pkt_head = &slave->frame.pkt_head;\n    int ret;\n\n    sunxi_spi_slave_head_data_parse(slave->frame.data, pkt_head);\n\n    if (!sunxi_spi_slave_has_ptk_head(pkt_head)) {\n        hal_log_debug("No Package head, wait revice from master");\n        pkt_head->op_code = SUNXI_OP_HEAD;\n        slave->xfer.rx_buf = slave->frame.data;\n        slave->xfer.rx_len = sizeof(slave->frame.data);\n    } else {\n        sunxi_spi_slave_head_data_clear(slave->frame.data, sizeof(slave->frame.data));\n        hal_log_debug("op=0x%x addr=0x%x len=0x%x", pkt_head->op_code, pkt_head->addr, pkt_head->len);\n\n        switch (pkt_head->op_code) {\n        case SUNXI_OP_WRITE:\n            slave->frame.rx_buf = hal_malloc(pkt_head->len);\n            slave->xfer.rx_buf = slave->frame.rx_buf;\n            slave->xfer.tx_buf = NULL;\n            slave->xfer.rx_len = pkt_head->len;\n            break;\n        case SUNXI_OP_READ:\n            slave->frame.tx_buf = hal_malloc(pkt_head->len);\n            slave->xfer.tx_buf = slave->frame.tx_buf;\n            slave->xfer.rx_buf = NULL;\n            slave->xfer.tx_len = pkt_head->len;\n            sunxi_spi_slave_get_cache_data(slave, pkt_head, (u8 *)slave->xfer.tx_buf);\n            hal_log_debug("sunxi slave get package operation read, send write buffer");\n            sunxi_spi_dump_data(slave->xfer.tx_buf, 0, slave->xfer.len);\n            break;\n        default:\n            hal_log_debug("unknown op code %d, wait revice from master", pkt_head->op_code);\n            sunxi_spi_slave_head_data_clear(slave->frame.data, sizeof(slave->frame.data));\n            pkt_head->op_code = SUNXI_OP_HEAD;\n            slave->xfer.rx_buf = slave->frame.data;\n            slave->xfer.tx_buf = NULL;\n            slave->xfer.rx_len = sizeof(slave->frame.data);\n            break;\n        }\n    }\n\n    return hal_spi_xfer(slave->port, &slave->xfer, 1);\n}\n\nstatic void spi_slave_driver_thread(void *pArg)\n{\n    struct sunxi_spi_slave_test *slave = (struct sunxi_spi_slave_test *)pArg;\n    struct sunxi_spi_slave_head *pkt_head;\n    int ret;\n\n    while (1) {\n        ret = sunxi_spi_slave_test_submit(slave);\n        if (ret != HAL_SPI_MASTER_OK) {\n            switch (slave->status) {\n            case SUNXI_SPI_SLAVE_RETRY:\n                hal_log_warn("slave transfer retry");\n                sunxi_spi_slave_head_data_clear(slave->frame.data, sizeof(slave->frame.data));\n                goto retry;\n                break;\n            case SUNXI_SPI_SLAVE_STOP:\n                hal_log_warn("slave transfer stop");\n                goto terminate;\n                break;\n            default:\n                hal_log_err("error status %d and ret %d", slave->status, ret);\n                break;\n            }\n        }\n\n        pkt_head = &slave->frame.pkt_head;\n        switch (pkt_head->op_code) {\n        case SUNXI_OP_HEAD:\n            hal_log_debug("sunxi slave get package head");\n            // sunxi_spi_dump_data(slave->xfer.rx_buf, 0, slave->xfer.len);\n            break;\n        case SUNXI_OP_WRITE:\n            hal_log_debug("sunxi slave get package operation write, recv read buffer");\n            // sunxi_spi_dump_data(slave->xfer.rx_buf, 0, slave->xfer.len);\n            sunxi_spi_slave_set_cache_data(slave, pkt_head, slave->xfer.rx_buf);\n            hal_free(slave->xfer.rx_buf);\n            slave->xfer.rx_buf = NULL;\n            slave->frame.rx_buf = NULL;\n            break;\n        case SUNXI_OP_READ:\n            hal_log_debug("send write buffer done");\n            hal_free((void *)slave->xfer.tx_buf);\n            slave->xfer.tx_buf = NULL;\n            slave->frame.tx_buf = NULL;\n            break;\n        default:\n            hal_log_debug("sunxi slave get op_code filed");\n            sunxi_spi_slave_head_data_clear(slave->frame.data, sizeof(slave->frame.data));\n            break;\n        }\n    retry:\n        memset(&slave->xfer, 0, sizeof(slave->xfer));\n    }\n\nterminate:\n    hal_sem_post(slave->semaphore_finished);\n}\n\nstatic int spi_slave_driver_abort(int port)\n{\n    struct sunxi_spi_slave_test *slave = &spi_slave_test[port];\n\n    hal_log_info("slave transfer abort");\n\n    slave->status = SUNXI_SPI_SLAVE_RETRY;\n    hal_spi_slave_abort(port);\n\n    return 0;\n}\n\nstatic int spi_slave_driver_dump(int port, int addr, int size)\n{\n    struct sunxi_spi_slave_test *slave = &spi_slave_test[port];\n\n    if (addr > slave->cache.size || addr + size > slave->cache.size) {\n        hal_log_err("dump addr/size out of bounds");\n        return -1;\n    }\n\n    sunxi_spi_dump_data(slave->cache.buffer, addr, size);\n\n    return 0;\n}\n\nstatic int spi_slave_driver_probe(int port, uint32_t freq)\n{\n    struct sunxi_spi_slave_test *slave = &spi_slave_test[port];\n\n    slave->port = port;\n    slave->cfg.clock_frequency = freq;\n    slave->cfg.chipselect = 0;\n    slave->cfg.mode = SPI_MODE_0;\n    slave->cfg.bus_mode = HAL_SPI_BUS_SLAVE;\n    if (HAL_SPI_MASTER_OK != hal_spi_init(slave->port, &slave->cfg)) {\n        hal_log_err("spi init failed");\n        return -1;\n    }\n\n    slave->semaphore_finished = hal_sem_create(0);\n    if (slave->semaphore_finished == NULL)\n    {\n        hal_log_err("[spi%d] creating semaphore_finished failed", slave->port);\n        return -1;\n    }\n\n    hal_spin_lock_init(&slave->cache.buffer_lock);\n    slave->cache.size = SLAVE_CACHE_MAX;\n    slave->cache.buffer = hal_malloc(slave->cache.size);\n    if (!slave->cache.buffer) {\n        hal_log_err("alloc slave cache memory failed (size %d)", slave->cache.size);\n        return -1;\n    }\n\n    sunxi_spi_init_slave_data(slave, 0xff);\n\n    snprintf(slave->task_name, sizeof(slave->task_name), "spi%d-slave-task\\0", slave->port);\n    slave->thread_handle = hal_thread_create(spi_slave_driver_thread, slave, slave->task_name,\n                            SPI_SLAVE_THREAD_STACK_SIZE, HAL_THREAD_PRIORITY_SYS);\n    if (slave->thread_handle == NULL) {\n        hal_log_err("create thread %s failed", slave->task_name);\n        return -1;\n    }\n\n    slave->status = SUNXI_SPI_SLAVE_RUNNING;\n\n    hal_thread_start(slave->thread_handle);\n\n    return 0;\n}\n\nstatic int spi_slave_driver_remove(int port)\n{\n    struct sunxi_spi_slave_test *slave = &spi_slave_test[port];\n\n    slave->status = SUNXI_SPI_SLAVE_STOP;\n    hal_spi_slave_abort(port);\n    hal_sem_wait(slave->semaphore_finished);\n    hal_thread_stop(slave->thread_handle);\n    hal_free(slave->cache.buffer);\n    hal_spin_lock_deinit(&slave->cache.buffer_lock);\n    hal_spi_deinit(slave->port);\n\n    return 0;\n}\n\nstatic void print_usage(const char *name)\n{\n    hal_log_info("Usage:");\n    hal_log_info("\\t%s probe <port> <freq>", name);\n    hal_log_info("\\t%s remove <port>", name);\n    hal_log_info("\\t%s abort <port>", name);\n    hal_log_info("\\t%s dump <port> <addr> <size>", name);\n}\n\nstatic int cmd_spi_slave_driver(int argc, const char **argv)\n{\n    int port;\n    uint32_t freq;\n    int addr, size;\n\n    if (argc < 3) {\n        print_usage(argv[0]);\n        return -1;\n    }\n\n    port = strtol(argv[2], NULL, 0);\n    if (port < 0 && port > HAL_SPI_MASTER_MAX) {\n        hal_log_err("spi port %d not exist", port);\n        return -1;\n    }\n\n    if (!strcmp(argv[1], "probe")) {\n        freq = strtol(argv[3], NULL, 0);\n        spi_slave_driver_probe(port, freq);\n    }\n    else if (!strcmp(argv[1], "remove"))\n        spi_slave_driver_remove(port);\n    else if (!strcmp(argv[1], "abort"))\n        spi_slave_driver_abort(port);\n    else if (!strcmp(argv[1], "dump")) {\n        addr = strtol(argv[3], NULL, 0);\n        size = strtol(argv[4], NULL, 0);\n        spi_slave_driver_dump(port, addr, size);\n    }\n    else\n        print_usage(argv[0]);\n\n    return 0;\n}\n\nFINSH_FUNCTION_EXPORT_CMD(cmd_spi_slave_driver, hal_spi_slave_driver, spi hal slave driver test)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"slave-\u6a21\u5f0f\u6d4b\u8bd5\u8303\u4f8b",children:"Slave \u6a21\u5f0f\u6d4b\u8bd5\u8303\u4f8b"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/time.h>\n\n#include <hal_log.h>\n#include <hal_cmd.h>\n#include <hal_mem.h>\n#include <hal_timer.h>\n#include <sunxi_hal_spi.h>\n#include <platform_spi.h>\n#define PKT_HEAD_LEN 5\n\n#define OP_MASK     0\n#define ADDR_MASK_0 1\n#define ADDR_MASK_1 2\n#define LEN_MASK_0  3\n#define LEN_MASK_1  4\n\n#define SUNXI_OP_WRITE  0x01\n#define SUNXI_OP_READ   0x03\n\n#define PKT_HEAD_DELAY  100\n#define PKT_XFER_DELAY  500\n\n#define KB (1024)\n#define MB (1024*KB)\n#define US (1)\n#define MS (1000*US)\n#define S  (1000*MS)\n\nstruct sunxi_spi_slave_head {\n    unsigned int op_code;\n    unsigned int addr;\n    unsigned int len;\n};\n\nstatic int verbose;\n\nstatic void hex_dump(const void *src, size_t length, size_t line_size,\n             char *prefix)\n{\n    int i = 0;\n    const unsigned char *address = src;\n    const unsigned char *line = address;\n    unsigned char c;\n\n    printf("%s | ", prefix);\n    while (length-- > 0) {\n        printf("%02X ", *address++);\n        if (!(++i % line_size) || (length == 0 && i % line_size)) {\n            if (length == 0) {\n                while (i++ % line_size)\n                    printf("__ ");\n            }\n            printf(" |");\n            while (line < address) {\n                c = *line++;\n                printf("%c", (c < 32 || c > 126) ? \'.\' : c);\n            }\n            printf("|\\n");\n            if (length > 0)\n                printf("%s | ", prefix);\n        }\n    }\n}\n\nstatic void show_transfer_info(unsigned long size, unsigned long time)\n{\n    double rate;\n\n    printf("total size   : ");\n    if (size >= MB) {\n        printf("%.2lf MB", (double)size/(double)MB);\n    } else if (size >= KB) {\n        printf("%.2lf KB", (double)size/(double)KB);\n    } else {\n        printf("%lu B", size);\n    }\n    printf("\\n");\n\n    printf("total time   : ");\n    if (time >= S) {\n        printf("%.2lf s", (double)time/(double)S);\n    } else if (time >= MS) {\n        printf("%.2lf ms", (double)time/(double)MS);\n    } else if (time >= US) {\n        printf("%.2lf us", (double)time/(double)US);\n    } else {\n        printf("%lu ns", time);\n    }\n    printf("\\n");\n\n    rate = ((double)size / (double)MB) / ((double)time / (double)S);\n    printf("averange rate: %.2lf MB/s\\n", rate);\n}\n\nstatic int transfer_pkg_create(char *buf, struct sunxi_spi_slave_head *head)\n{\n    buf[OP_MASK] = head->op_code;\n    buf[ADDR_MASK_0] = (head->addr >> 8) & 0xff;\n    buf[ADDR_MASK_1] = head->addr & 0xff;\n    buf[LEN_MASK_0] = (head->len >> 8) & 0xff;\n    buf[LEN_MASK_1] = head->len & 0xff;\n\n    return 0;\n}\n\nstatic int transfer_slave_package(int port, struct sunxi_spi_slave_head *head, char *tx_buf, char *rx_buf)\n{\n    char head_buf[PKT_HEAD_LEN];\n    hal_spi_master_transfer_t tr[2];\n    int i;\n    int ret;\n\n    memset(tr, 0, sizeof(tr));\n\n    transfer_pkg_create(head_buf, head);\n    if (verbose) {\n        printf("package head : { ");\n        for (i = 0; i < PKT_HEAD_LEN; i++) {\n            printf("0x%02x ", head_buf[i]);\n        }\n        printf("}\\n");\n    }\n\n    tr[0].tx_buf = (uint8_t *)head_buf;\n    tr[0].tx_nbits = SPI_NBITS_SINGLE;\n    tr[0].tx_len = sizeof(head_buf);\n    tr[0].tx_single_len = sizeof(head_buf);\n    tr[0].rx_buf = (uint8_t *)NULL;\n    tr[0].rx_nbits = 0;\n    tr[0].rx_len = 0;\n\n    tr[1].tx_buf = (uint8_t *)tx_buf;\n    tr[1].tx_nbits = SPI_NBITS_SINGLE;\n    tr[1].tx_len = head->len;\n    tr[1].tx_single_len = head->len;\n    tr[1].rx_buf = (uint8_t *)rx_buf;\n    tr[1].rx_nbits = SPI_NBITS_SINGLE;\n    tr[1].rx_len = head->len;\n\n    hal_spi_xfer(port, &tr[0], 1);\n    hal_usleep(PKT_HEAD_DELAY);\n    hal_spi_xfer(port, &tr[1], 1);\n\n    return 0;\n}\n\nstatic int transfer_slave(int port, uint32_t addr, uint32_t size)\n{\n    struct sunxi_spi_slave_head pkt_head;\n    char *tx_buf = NULL;\n    char *rx_buf = NULL;\n    struct timeval start, end;\n    unsigned long nsec = 0;\n    int i;\n\n    tx_buf = hal_malloc(size);\n    srand(time(0));\n    for (i = 0; i < size; i++)\n        tx_buf[i] = random() % 256;\n\n    rx_buf = hal_malloc(size);\n    memset(rx_buf, 0, size);\n\n    gettimeofday(&start, NULL);\n    // Write forward\n    pkt_head.op_code = SUNXI_OP_WRITE;\n    pkt_head.addr = addr;\n    pkt_head.len = size;\n    transfer_slave_package(port, &pkt_head, tx_buf, NULL);\n    hal_usleep(PKT_XFER_DELAY);\n    // Read back\n    pkt_head.op_code = SUNXI_OP_READ;\n    pkt_head.addr = addr;\n    pkt_head.len = size;\n    transfer_slave_package(port, &pkt_head, NULL, rx_buf);\n    gettimeofday(&end, NULL);\n    // Debug\n    if (verbose) {\n        hex_dump(tx_buf, size, 32, "TX");\n        hex_dump(rx_buf, size, 32, "RX");\n    }\n    // Compare buffer\n    if (memcmp(tx_buf, rx_buf, size))\n        printf("rx/tx buffer is not same, compare error!!!\\n");\n    else\n        nsec += (1000000 * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec);\n\n    free(tx_buf);\n    free(rx_buf);\n\n    return nsec;\n}\n\nstatic void print_usage(const char *name)\n{\n    hal_log_info("Usage:");\n    hal_log_info("\\t%s <port> <freq> <addr> <size> <loop> [debug]", name);\n}\n\nstatic int cmd_test_spi_slave(int argc, const char **argv)\n{\n    int  port;\n    hal_spi_master_config_t cfg;\n    uint32_t addr, size;\n    int loop = 1;\n    unsigned long usec;\n    unsigned long total_usec = 0;\n    unsigned long total_size = 0;\n    int i;\n\n    if (argc < 6) {\n        print_usage(argv[0]);\n        return -1;\n    }\n\n    memset(&cfg, 0, sizeof(cfg));\n    port = strtol(argv[1], NULL, 0);\n    if (port < 0 && port > HAL_SPI_MASTER_MAX) {\n        hal_log_err("spi port %d not exist", port);\n        return -1;\n    }\n\n    addr = strtol(argv[3], NULL, 0);\n    size = strtol(argv[4], NULL, 0);\n    loop = strtol(argv[5], NULL, 0);\n\n    if (argc == 7 && strcmp(argv[6], "debug") == 0)\n        verbose = 1;\n    else \n        verbose = 0;\n\n    hal_log_info("run spi slave test");\n\n    cfg.clock_frequency = strtol(argv[2], NULL, 0);\n    cfg.chipselect = 0;\n    cfg.mode = SPI_MODE_0;\n    cfg.bus_mode = HAL_SPI_BUS_MASTER;\n    hal_spi_init(port, &cfg);\n\n    hal_log_info("max speed: %u Hz (%u kHz)", cfg.clock_frequency, cfg.clock_frequency/1000);\n    hal_log_info("op addr : %d", addr);\n    hal_log_info("op size : %d", size);\n\n    if (size) {\n        for (i = 0; i < loop; i++) {\n            usec = transfer_slave(port, addr, size);\n            if (usec) {\n                total_usec += usec;\n                total_size += (size * 2);\n            }\n        }\n        show_transfer_info(total_size, total_usec);\n        printf("averange time: %.2lf us\\n", (double)total_usec/(double)US/(double)(loop));\n    }\n\n    hal_spi_deinit(port);\n\n    hal_log_info("spi slave test finish");\n\n    return 0;\n}\n\nFINSH_FUNCTION_EXPORT_CMD(cmd_test_spi_slave, hal_spi_slave_test, spi hal slave tests)\n'})}),"\n",(0,i.jsx)(e.h1,{id:"\u8c03\u8bd5\u65b9\u6cd5",children:"\u8c03\u8bd5\u65b9\u6cd5"}),"\n",(0,i.jsxs)(e.p,{children:["\u4f7f\u7528 ",(0,i.jsx)(e.code,{children:"hal_log_info/warn/err/debug"})," \u7b49\u8c03\u8bd5\u6253\u5370\u65b9\u6cd5\uff0c\u53ef\u4ee5\u6839\u636e\u9700\u6c42\u4fee\u6539\u7cfb\u7edf\u914d\u7f6e\uff0c\u8fbe\u5230\u4e0d\u540c\u7684\u6253\u5370\u7b49\u7ea7"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#define SPI_INFO(sspi, fmt, arg...) hal_log_info("hal-sspi %08lx.sspi%d: " fmt, sspi->base, sspi->bus_num, ##arg)\n#define SPI_WARN(sspi, fmt, arg...) hal_log_warn("hal-sspi %08lx.sspi%d: " fmt, sspi->base, sspi->bus_num, ##arg)\n#define SPI_ERR(sspi, fmt, arg...)  hal_log_err("hal-sspi %08lx.sspi%d: " fmt, sspi->base, sspi->bus_num, ##arg)\n#define SPI_DBG(sspi, fmt, arg...)  hal_log_debug("hal-sspi %08lx.sspi%d: " fmt, sspi->base, sspi->bus_num, ##arg)\n'})}),"\n",(0,i.jsxs)(e.p,{children:["\u4f7f\u7528 ",(0,i.jsx)(e.code,{children:"SPI_DATA_LEVEL/SPI_DUMPREG_LEVEL"})," \u5b8f\u5f00\u5173\uff0c\u53ef\u4ee5\u5728\u4f20\u8f93\u7684\u8fc7\u7a0b\u4e2d\u6253\u5370\u6536\u53d1\u6570\u636e ",(0,i.jsx)(e.code,{children:"buffer"})," \u53ca\u63a7\u5236\u5668\u5bc4\u5b58\u5668\u503c"]}),"\n",(0,i.jsx)(e.h2,{id:"\u8c03\u8bd5\u5de5\u5177",children:"\u8c03\u8bd5\u5de5\u5177"}),"\n",(0,i.jsxs)(e.p,{children:["\u5982\u679c\u5728 ",(0,i.jsx)(e.code,{children:"menuconfig"})," \u4e2d\u5c06 ",(0,i.jsx)(e.code,{children:"spi test"})," \u914d\u7f6e\u6253\u5f00\uff0c\u90a3\u4e48\u53ef\u4ee5\u5728 RTOS \u7cfb\u7edf\u4e2d\u8fd0\u884c\u76f8\u5e94\u7684 SPI \u8c03\u8bd5\u547d\u4ee4\u3002"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"hal_spidev_test"})," \u6d4b\u8bd5SPI Single\u6a21\u5f0f\uff0c\u53ef\u4ee5\u914d\u7f6e\u7aef\u53e3\uff0c\u9891\u7387\uff0c\u6570\u636e\u91cf\uff0c\u5faa\u73af\u6b21\u6570\u7b49\u53c2\u6570"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"hal_spidev_test -D <port> -s <freq> -S <size> -I <loop> [-v]"})}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"hal_spi_slave_driver"})," Slave\u6a21\u5f0f\u9a71\u52a8\uff0c\u9700\u8981\u5148\u518dslave\u8bbe\u5907\u7aef\u8dd1\u8d77\u8be5\u9a71\u52a8\uff0c\u624d\u80fd\u5728master\u7aef\u8fdb\u884c\u76f8\u5e94\u6d4b\u8bd5"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"hal_spi_slave_driver probe <port> <freq>"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"hal_spi_slave_driver remove <port>"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"hal_spi_slave_driver abort <port>"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"hal_spi_slave_driver dump <port> <addr> <size>"})}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"hal_spi_slave_test"})," Slave\u6a21\u5f0f\u6d4b\u8bd5\u547d\u4ee4\uff0c\u8be5\u547d\u4ee4\u9700\u8981\u5728master\u7aef\u8fd0\u884c"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"hal_spi_slave_test <port> <freq> <addr> <size> <loop> [debug]"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"faq",children:"FAQ"}),"\n",(0,i.jsx)(e.h3,{id:"\u591a\u7b14\u6570\u636e\u8fde\u7eed\u53d1\u9001\u65f6\u5982\u4f55\u8ba9cs\u811a\u4fdd\u6301\u4f7f\u80fd",children:"\u591a\u7b14\u6570\u636e\u8fde\u7eed\u53d1\u9001\u65f6\uff0c\u5982\u4f55\u8ba9CS\u811a\u4fdd\u6301\u4f7f\u80fd"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\u95ee\u9898\u73b0\u8c61"}),"\uff1a\u6bcf\u5305\u6570\u636e\u53d1\u9001\u540e\uff0cCS\u811a\u90fd\u4f1a\u7ffb\u8f6c\u4e00\u6b21\uff0c\u91cd\u65b0\u4f7f\u80fd\uff0c\u5bfc\u81f4\u4e0e\u5916\u8bbe\u901a\u4fe1\u5f02\u5e38"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"http://photos.100ask.net/aw-r128-docs/rtos/developer-guide/part2/chapter25/image2.png",alt:""})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\u89e3\u51b3\u65b9\u6cd5"}),"\uff1a\u5c06 ",(0,i.jsx)(e.code,{children:"cs_mode"})," \u914d\u7f6e\u4e3a\u624b\u52a8\uff0c\u5e76\u5c06\u9700\u8981CS\u4fe1\u53f7\u5305\u5728\u5185\u7684\u591a\u5305\u6570\u636e\uff0c\u4e00\u6b21\u6027\u4f20\u7ed9\u9a71\u52a8"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"hal_spi_master_config_t cfg = { 0 };\nhal_spi_master_transfer_t tr[2];\n......\ncfg.cs_mode = HAL_SPI_CS_SOFT;\n......\nhal_spi_init(port, &cfg);\n......\nhal_spi_xfer(port, &tr, ARRAY_SIZE(tr));\n"})})]})}function h(n={}){const{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},1151:(n,e,s)=>{s.d(e,{Z:()=>r,a:()=>_});var i=s(7294);const t={},a=i.createContext(t);function _(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:_(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9802],{4088:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>o});var t=r(5893),i=r(1151);const a={},d="MMC",s={id:"developer-guide/part2/chapter18",title:"MMC",description:"MMC \u7279\u6027",source:"@site/docs/developer-guide/part2/chapter18.md",sourceDirName:"developer-guide/part2",slug:"/developer-guide/part2/chapter18",permalink:"/developer-guide/part2/chapter18",draft:!1,unlisted:!1,editUrl:"https://github.com/100askTeam/R128-Docs/tree/main/docs/developer-guide/part2/chapter18.md",tags:[],version:"current",frontMatter:{},sidebar:"classpartoneSidebar",previous:{title:"Mbus",permalink:"/developer-guide/part2/chapter17"},next:{title:"MSGBOX",permalink:"/developer-guide/part2/chapter19"}},c={},o=[{value:"MMC \u7279\u6027",id:"mmc-\u7279\u6027",level:2},{value:"\u6a21\u5757\u4ecb\u7ecd",id:"\u6a21\u5757\u4ecb\u7ecd",level:2},{value:"\u6a21\u5757\u914d\u7f6e",id:"\u6a21\u5757\u914d\u7f6e",level:2},{value:"\u6e90\u7801\u7ed3\u6784",id:"\u6e90\u7801\u7ed3\u6784",level:2},{value:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",level:2},{value:"SDMMC \u63a5\u53e3",id:"sdmmc-\u63a5\u53e3",level:3},{value:"SDIO \u63a5\u53e3",id:"sdio-\u63a5\u53e3",level:3}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"mmc",children:"MMC"}),"\n",(0,t.jsx)(e.h2,{id:"mmc-\u7279\u6027",children:"MMC \u7279\u6027"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Compatible with Secure Digital Memory (SD mem-version 2.0)"}),"\n",(0,t.jsx)(e.li,{children:"Compatible with Secure Digital I/O (SDIO-version 3.0)"}),"\n",(0,t.jsx)(e.li,{children:"Compatible with embedded MultiMediaCard (eMMC-version 5.0)"}),"\n",(0,t.jsx)(e.li,{children:"Supports Card insertion and removal interrupt"}),"\n",(0,t.jsx)(e.li,{children:"Supports hardware CRC generation and error detection"}),"\n",(0,t.jsx)(e.li,{children:"Supports programmable baud rate"}),"\n",(0,t.jsx)(e.li,{children:"Supports SDIO interrupts in 1-bit and 4-bit modes"}),"\n",(0,t.jsx)(e.li,{children:"Supports block size of 1 to 65535 bytes"}),"\n",(0,t.jsx)(e.li,{children:"Supports descriptor-based internal DMA controller"}),"\n",(0,t.jsx)(e.li,{children:"Internal 1024-Bytes RX FIFO and 1024-Bytes TX FIFO"}),"\n",(0,t.jsx)(e.li,{children:"Supports 1-bit, 4-bit SD and SDIO data bus width"}),"\n",(0,t.jsx)(e.li,{children:"Supports 1-bit, 4-bit eMMC data bus width"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"\u6a21\u5757\u4ecb\u7ecd",children:"\u6a21\u5757\u4ecb\u7ecd"}),"\n",(0,t.jsx)(e.p,{children:"RTOS \u63d0\u4f9b\u4e86MMC \u5b50\u7cfb\u7edf\u6765\u5b9e\u73b0\u5bf9\u5404\u79cdSD/SDIO \u8bbe\u5907\u8bbf\u95ee\uff0cMMC \u5b50\u7cfb\u7edf\u7531\u4e0a\u5230\u4e0b\u53ef\u4ee5\u5206\u4e3a\u4e09\u5c42\uff0cMMC/SD card \u5c42\uff0cMMC/SD core \u5c42\u4ee5\u53caMMC/SD host \u5c42\uff0c\u5b83\u4eec\u4e4b\u95f4\u7684\u5c42\u6b21\u5173\u7cfb\u5982\u4e0b\u6240\u793a\u3002"}),"\n",(0,t.jsx)(e.p,{children:"MMC/SD card \u5c42\u8d1f\u4e3b\u8981\u662f\u6309\u7167RTOS \u5757\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u7684\u6846\u67b6\u5b9e\u73b0\u4e00\u4e2a\u5361\u7684\u5757\u8bbe\u5907\u9a71\u52a8\u3002\u8d1f\u8d23\u5757\u8bbe\u5907\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u4ee5\u53ca\u8bf7\u6c42\u961f\u5217\u7684\u7ba1\u7406\u3002MMC/SD core \u5c42\u8d1f\u8d23\u901a\u4fe1\u534f\u8bae\u7684\u5904\u7406\uff0c\u5305\u62ecSD/SDIO\uff0c\u4e3a\u4e0a\u4e00\u5c42\u63d0\u4f9b\u5177\u4f53\u8bfb\u5199\u63a5\u53e3\uff0c\u540c\u65f6\u4e3a\u4e0b\u4e00\u5c42\u63d0\u4f9bhost \u7aef\u63a5\u53e3\u3002MMC/SD host \u662f\u5b9e\u73b0\u5bf9SD/MMC \u63a7\u5236\u5668\u76f8\u5173\u7684\u64cd\u4f5c\uff0c\u76f4\u63a5\u64cd\u4f5c\u786c\u4ef6\uff0c\u4e5f\u662f\u4e3b\u8981\u5b9e\u73b0\u90e8\u5206\u3002"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"http://photos.100ask.net/aw-r128-docs/rtos/developer-guide/part2/chapter18/image1.jpg",alt:"image1"})}),"\n",(0,t.jsx)(e.h2,{id:"\u6a21\u5757\u914d\u7f6e",children:"\u6a21\u5757\u914d\u7f6e"}),"\n",(0,t.jsx)(e.p,{children:"\u5176 menuconfig \u7684\u914d\u7f6e\u5982\u4e0b\uff1a"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Kernel Setup ---\x3e\n    Drivers Setup ---\x3e\n        SoC HAL Drivers ---\x3e\n            SDMMC devices ---\x3e\n                [*] enable SDMMC drivers    \n                -*-   enable SD\n                [*]   enable SDIO\n                [ ]   enable mmc\n                [ ]   enable emmc\n                [ ]   enable detect card\n                [*]   enable dma transmission\n                [*]   enable sdio irq\n                [*]   enable SD Card test case.\n                (64)  SD Card Align DMA Buffer Size(Kbyte).\n                (0)   sdc card detect pin present value\n                [*]   support SDMMC filesystem\n"})}),"\n",(0,t.jsx)(e.h2,{id:"\u6e90\u7801\u7ed3\u6784",children:"\u6e90\u7801\u7ed3\u6784"}),"\n",(0,t.jsx)(e.p,{children:"MMC \u6a21\u5757\u6e90\u7801\u7ed3\u6784\u5982\u4e0b\u6240\u793a\uff1a"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:".\n\u251c\u2500\u2500 cmd\n\u2502   \u251c\u2500\u2500 cmd_sd.c\n\u2502   \u2514\u2500\u2500 Kconfig\n\u251c\u2500\u2500 core.c\n\u251c\u2500\u2500 _core.h\n\u251c\u2500\u2500 hal\n\u2502   \u2514\u2500\u2500 hal_ccm.c\n\u251c\u2500\u2500 hal_sdhost.c\n\u251c\u2500\u2500 hal_sdpin.c\n\u251c\u2500\u2500 Kconfig\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 mmc.c\n\u251c\u2500\u2500 _mmc.h\n\u251c\u2500\u2500 osal\n\u2502   \u251c\u2500\u2500 Makefile\n\u2502   \u2514\u2500\u2500 os\n\u2502       \u251c\u2500\u2500 FreeRTOS\n\u2502       \u2502   \u251c\u2500\u2500 Makefile\n\u2502       \u2502   \u251c\u2500\u2500 os_debug.c\n\u2502       \u2502   \u251c\u2500\u2500 os_debug.h\n\u2502       \u2502   \u251c\u2500\u2500 os_mutex.c\n\u2502       \u2502   \u251c\u2500\u2500 os_queue.c\n\u2502       \u2502   \u251c\u2500\u2500 os_semaphore.c\n\u2502       \u2502   \u251c\u2500\u2500 os_thread.c\n\u2502       \u2502   \u251c\u2500\u2500 os_timer.c\n\u2502       \u2502   \u2514\u2500\u2500 os_util.h\n\u2502       \u251c\u2500\u2500 Kconfig\n\u2502       \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 platform\n\u2502   \u2514\u2500\u2500 mmc_sun20iw2p1.h\n\u251c\u2500\u2500 platform_mmc.h\n\u251c\u2500\u2500 quirks.c\n\u251c\u2500\u2500 sd.c\n\u251c\u2500\u2500 _sd_define.h\n\u251c\u2500\u2500 _sd.h\n\u251c\u2500\u2500 _sdhost.h\n\u251c\u2500\u2500 sdio.c\n\u251c\u2500\u2500 _sdio.h\n\u251c\u2500\u2500 sdio_irq.c\n\u2514\u2500\u2500 test.c\n"})}),"\n",(0,t.jsx)(e.h2,{id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",children:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e"}),"\n",(0,t.jsx)(e.h3,{id:"sdmmc-\u63a5\u53e3",children:"SDMMC \u63a5\u53e3"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:"/**\n * @brief read SD card.\n * @param card:\n *        @arg card->card handler.\n * @param buf:\n *        @arg buf->for store readed data.\n * @param sblk:\n *        @arg sblk->start block num.\n * @param nblk:\n *        @arg nblk->number of blocks.\n * @retval  0 if success or other if failed.\n */\nextern int32_t mmc_block_read(struct mmc_card *card, uint8_t *buf, uint64_t sblk, uint32_t nblk);\n\n/**\n * @brief write SD card.\n * @param card:\n *        @arg card->card handler.\n * @param buf:\n *        @arg buf->data will be write.\n * @param sblk:\n *        @arg sblk->start block num.\n * @param nblk:\n *        @arg nblk->number of blocks.\n * @retval  0 if success or other if failed.\n */\nextern int32_t mmc_block_write(struct mmc_card *card, const uint8_t *buf, uint64_t sblk, uint32_t nblk);\n\n/**\n * @brief scan or rescan SD card.\n * @param card:\n *        @arg card->card handler.\n * @param sdc_id:\n *        @arg sdc_id->SDC ID which card on.\n * @retval  0 if success or other if failed.\n */\nextern int32_t mmc_rescan(struct mmc_card *card, uint32_t sdc_id);\n\n/**\n * @brief deinit SD card.\n * @param card:\n *        @arg card->card handler.\n * @retval  0 if success or other if failed.\n */\nextern int32_t mmc_card_deinit(struct mmc_card *card);\n\n/**\n * @brief malloc for card_info.\n * @param card_id:\n *        @arg card ID.\n * @retval  0 if success or other if failed.\n */\nextern int32_t mmc_card_create(uint8_t card_id, SDCard_InitTypeDef *param);\n\n/**\n * @brief free for card_info.\n * @param card_id:\n *        @arg card ID.\n * @retval  0 if success or other if failed.\n */\nextern int32_t mmc_card_delete(uint8_t card_id);\n\n/**\n * @brief get pointer of mmc_card.\n * @param card_id:\n *        @arg card ID.\n * @retval  pointer of mmc_card if success or NULL if failed.\n */\nextern struct mmc_card* mmc_card_open(uint8_t card_id);\n\n/**\n * @brief close mmc_card.\n * @param card_id:\n *        @arg card ID.\n * @retval  0 if success or other if failed.\n */\nextern int32_t mmc_card_close(uint8_t card_id);\nextern struct mmc_card_info* mmc_card_save(uint8_t card_id);\nextern int32_t mmc_card_restore(struct mmc_card_info *s_card_info);\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sdio-\u63a5\u53e3",children:"SDIO \u63a5\u53e3"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:"typedef struct mmc_card sdio_t;\n\n/**\n *  sdio_readb - read a single byte from a SDIO function\n *  @card: SDIO to access\n *  @addr: address to read\n *  @err_ret: optional status value from transfer\n *\n *  Reads a single byte from the address space of a given SDIO\n *  function. If there is a problem reading the address, 0xff\n *  is returned and @err_ret will contain the error code.\n */\nextern uint8_t\nsdio_readb(struct mmc_card *card, uint32_t func_num, uint32_t addr,\n           int32_t *err_ret);\n\n/**\n *  sdio_writeb - write a single byte to a SDIO function\n *  @card: SDIO to access\n *  @b: byte to write\n *  @addr: address to write to\n *  @err_ret: optional status value from transfer\n *\n *  Writes a single byte to the address space of a given SDIO\n *  function. @err_ret will contain the status of the actual\n *  transfer.\n */\nextern void\nsdio_writeb(struct mmc_card *card, uint32_t func_num, const uint8_t b,\n            uint32_t addr, int32_t  *err_ret);\n\n/**\n *  sdio_readw - read a 16 bit integer from a SDIO function\n *  @func: SDIO function to access\n *  @addr: address to read\n *  @err_ret: optional status value from transfer\n *\n *  Reads a 16 bit integer from the address space of a given SDIO\n *  function. If there is a problem reading the address, 0xffff\n *  is returned and @err_ret will contain the error code.\n */\nextern uint16_t sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);\n/**\n *  sdio_writew - write a 16 bit integer to a SDIO function\n *  @func: SDIO function to access\n *  @b: integer to write\n *  @addr: address to write to\n *  @err_ret: optional status value from transfer\n *\n *  Writes a 16 bit integer to the address space of a given SDIO\n *  function. @err_ret will contain the status of the actual\n *  transfer.\n */\nextern void sdio_writew(struct sdio_func *func, uint16_t b, unsigned int addr, int *err_ret);\n/**\n *  sdio_readl - read a 32 bit integer from a SDIO function\n *  @func: SDIO function to access\n *  @addr: address to read\n *  @err_ret: optional status value from transfer\n *\n *  Reads a 32 bit integer from the address space of a given SDIO\n *  function. If there is a problem reading the address,\n *  0xffffffff is returned and @err_ret will contain the error\n *  code.\n */\nextern uint32_t sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);\n/**\n *  sdio_writel - write a 32 bit integer to a SDIO function\n *  @func: SDIO function to access\n *  @b: integer to write\n *  @addr: address to write to\n *  @err_ret: optional status value from transfer\n *\n *  Writes a 32 bit integer to the address space of a given SDIO\n *  function. @err_ret will contain the status of the actual\n *  transfer.\n */\nextern void sdio_writel(struct sdio_func *func, uint32_t b, unsigned int addr, int *err_ret);\n\n/**\n *  memcpy_fromio - read a chunk of memory from a SDIO function\n *  @dst: buffer to store the data\n *  @addr: address to begin reading from\n *  @count: number of bytes to read\n *\n *  Reads from the address space of a given SDIO function. Return\n *  value indicates if the transfer succeeded or not.\n */\nextern int\nsdio_memcpy_fromio(struct mmc_card *card, unsigned int func_num, void *dst,\n                   unsigned int addr, int count);\n\n/**\n *  memcpy_toio - write a chunk of memory to a SDIO function\n *  @addr: address to start writing to\n *  @src: buffer that contains the data to write\n *  @count: number of bytes to write\n *\n *  Writes to the address space of a given SDIO function. Return\n *  value indicates if the transfer succeeded or not.\n */\nextern int\nsdio_memcpy_toio(struct mmc_card *card, unsigned int func_num, unsigned int addr,\n                 const void *src, int count);\n\n/**\n *    sdio_claim_irq - claim the IRQ for a SDIO function\n *    @card: SDIO card\n *    @func_num: function num\n *    @handler: IRQ handler callback\n *\n *    Claim and activate the IRQ for the given SDIO function. The provided\n *    handler will be called when that IRQ is asserted.  The host is always\n *    claimed already when the handler is called so the handler must not\n *    call sdio_claim_host() nor sdio_release_host().\n */\n//extern int sdio_claim_irq(struct mmc_card *card, unsigned int func_num,\n//                          sdio_irq_handler_t *handler);\nextern int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler);\n\n/**\n *    sdio_release_irq - release the IRQ for a SDIO function\n *    @card: SDIO card\n *    @func_num: function num\n *\n *    Disable and release the IRQ for the given SDIO function.\n */\n//extern int sdio_release_irq(struct mmc_card *card, unsigned int func_num);\nextern int sdio_release_irq(struct sdio_func *func);\n\n/**\n *  sdio_align_size - pads a transfer size to a more optimal value\n *  @func: SDIO function\n *  @sz: original transfer size\n *\n *  Pads the original data size with a number of extra bytes in\n *  order to avoid controller bugs and/or performance hits\n *  (e.g. some controllers revert to PIO for certain sizes).\n *\n *  If possible, it will also adjust the size so that it can be\n *  handled in just a single request.\n *\n *  Returns the improved size, which might be unmodified.\n */\n//unsigned int sdio_align_size(struct mmc_card *card, unsigned int sz);\nunsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);\n"})})]})}function u(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(l,{...n})}):l(n)}},1151:(n,e,r)=>{r.d(e,{Z:()=>s,a:()=>d});var t=r(7294);const i={},a=t.createContext(i);function d(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:d(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);